diff -urNa openMosix-2.4.21/arch/i386/config.in Migshm-2.4.21/arch/i386/config.in
--- openMosix-2.4.21/arch/i386/config.in	2003-07-12 11:14:02.000000000 +0530
+++ Migshm-2.4.21/arch/i386/config.in	2003-07-12 12:09:47.000000000 +0530
@@ -28,6 +28,12 @@
 	bool 'Poll/Select exceptions on pipes' CONFIG_MOSIX_PIPE_EXCEPTIONS
 	bool 'Disable OOM Killer' CONFIG_openMosix_NO_OOM
 	bool 'Load Limit' CONFIG_MOSIX_LOADLIMIT
+        bool 'Shared memory migration support (Experimental)' CONFIG_SHM
+        if [ "$CONFIG_SHM" = "y" ]; then
+                bool '  flush() support for consistency' CONFIG_SHM_FLUSH
+                bool '  Kernel Debug messages' CONFIG_SHM_DEBUG
+	fi
+
 fi
 endmenu
 
diff -urNa openMosix-2.4.21/arch/i386/defconfig Migshm-2.4.21/arch/i386/defconfig
--- openMosix-2.4.21/arch/i386/defconfig	2003-07-12 11:14:02.000000000 +0530
+++ Migshm-2.4.21/arch/i386/defconfig	2003-07-12 12:05:59.000000000 +0530
@@ -20,7 +20,9 @@
 # CONFIG_MOSIX_DFSA is not set
 # CONFIG_MOSIX_FS is not set
 # CONFIG_MOSIX_PIPE_EXCEPTIONS is not set
-
+CONFIG_SHM=y
+CONFIG_SHM_FLUSH=y
+CONFIG_SHM_DEBUG=y
 CONFIG_X86=y
 CONFIG_ISA=y
 # CONFIG_SBUS is not set
diff -urNa openMosix-2.4.21/arch/i386/kernel/entry.S Migshm-2.4.21/arch/i386/kernel/entry.S
--- openMosix-2.4.21/arch/i386/kernel/entry.S	2003-07-12 11:14:02.000000000 +0530
+++ Migshm-2.4.21/arch/i386/kernel/entry.S	2003-07-12 12:05:59.000000000 +0530
@@ -804,6 +804,11 @@
  	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_remap_file_pages */
  	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_set_tid_address */
 
+#ifdef CONFIG_SHM
+        .long SYMBOL_NAME(sys_printlogs)
+        .long SYMBOL_NAME(sys_flush)
+#endif /* CONFIG_SHM */
+
 	.rept NR_syscalls-(.-sys_call_table)/4
 		.long SYMBOL_NAME(sys_ni_syscall)
 	.endr
diff -urNa openMosix-2.4.21/arch/i386/kernel/process.c Migshm-2.4.21/arch/i386/kernel/process.c
--- openMosix-2.4.21/arch/i386/kernel/process.c	2003-07-12 11:14:02.000000000 +0530
+++ Migshm-2.4.21/arch/i386/kernel/process.c	2003-07-12 12:05:59.000000000 +0530
@@ -840,7 +840,12 @@
 		return(retval);
 	retval = do_fork(clone_flags, newsp, &regs, 0);
 	if(clone_flags & CLONE_VM)
+	{
 		mosix_post_clone();
+#ifdef CONFIG_SHM
+			current->mosix.stay |= DSTAY_FOR_CLONE;
+#endif /* CONFIG_SHM */
+	}
 	return(retval);
 #else
 	return do_fork(clone_flags, newsp, &regs, 0);
diff -urNa openMosix-2.4.21/Documentation/Configure.help Migshm-2.4.21/Documentation/Configure.help
--- openMosix-2.4.21/Documentation/Configure.help	2003-07-12 11:14:02.000000000 +0530
+++ Migshm-2.4.21/Documentation/Configure.help	2003-07-12 12:05:59.000000000 +0530
@@ -284,6 +284,29 @@
    a shortage of RAM + Swapspace to accomdate them all and then the OOM killer
    kicks in. Turn this feature on to avoid using the OOM killer.
 
+Shared memory migration support
+CONFIG_SHM
+  This option is intended for enabling the shared memory applications 
+  to benefit from the openMosix cluster. 
+  Say Y to enable migration of shared memory processes across nodes of 
+  your cluster.
+
+flush() support for consistency
+CONFIG_SHM_FLUSH
+  Applications which do not need synchronization and are thus satisfied
+  by weak consistency, can still maitain this policy remotely. The
+  programmer can explicitly flush out the changes to the shared region 
+  to any remote owner of the shared region, at any time during the
+  program execution, by calling the "flush()" system call. 
+  Thus, even if the applications do not use semaphores, they can
+  achieve consistency using the flush() call.
+
+Kernel Debug messages
+CONFIG_SHM_DEBUG
+  Say Y to get debug messages about shared memory processes. The 
+  messages include comprehencive messages about most of the error 
+  conditions and migration messages. 
+
 Symmetric Multi-Processing support
 CONFIG_SMP
   This enables support for systems with more than one CPU. If you have
diff -urNa openMosix-2.4.21/hpc/balance.c Migshm-2.4.21/hpc/balance.c
--- openMosix-2.4.21/hpc/balance.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/balance.c	2003-07-12 12:12:01.000000000 +0530
@@ -6,7 +6,12 @@
  *
  * Author(s): Amnon Shiloh, Amnon Barak, Moshe Bar
  */
-
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/module.h>
 #include <linux/sched.h>
@@ -28,6 +33,11 @@
 #ifdef CONFIG_MOSIX_FS
 #include <linux/mfs.h>
 #endif /* CONFIG_MOSIX_FS */
+#ifdef CONFIG_SHM
+#include <mig_shm/log_info.h>
+#include <mig_shm/shm_comm.h>
+#include <mig_shm/load.h>
+#endif /*CONFIG_SHM*/
 
 struct opcost remote_here_adjusted[MAX_MOSIX_TOPOLOGY];
 #ifndef CONFIG_MOSIX_TOPOLOGY
@@ -436,6 +446,13 @@
 	}
         sel->mosix.last_consider += lastpri;
 	chosen_for_balance = sel;
+
+#ifdef CONFIG_SHM	
+	/* if process is not running remotely we want ro call chosse others */
+	sel->mosix.mig_flags &= ~OVERRIDE;
+	choose_others(chosen_for_balance, BALANCE);
+#endif /* CONFIG_SHM */
+      
 	mosix_do_add_to_whereto(sel, BALANCE);
 	load_balancing_counter = BALANCING_TIMEOUT;
 	if(sel->mosix.whereto != BALANCE)
@@ -598,15 +615,34 @@
 	struct mfs_stats mfs;
 #endif /* CONFIG_MOSIX_FS */
 };
+#ifdef CONFIG_SHM
+#define MAX_CONSIDERED  (INFO_WIN+1+MAX_MFS_STATNODES)
+#if MAX_CONSIDERED > 127
+#error char is not enough for map
+#endif /*MAX_CONSIDERED*/
+#endif /* CONFIG_SHM */
 
 void
 consider(int reason, struct sonstats *sons)
 {
+#ifndef CONFIG_SHM
 #define	MAX_CONSIDERED	(INFO_WIN+1+MAX_MFS_STATNODES)
 #if MAX_CONSIDERED > 127
 #error char is not enough for map
 #endif /*MAX_CONSIDERED*/
+#endif /* CONFIG_SHM */
+
 	struct task_struct *p = current;
+#ifdef CONFIG_SHM
+	struct task_struct *q = NULL;
+	struct shmeminfo *shm, *travshm;
+	int override_arr[10], l;
+	int psret, shmid = -1;
+	struct shm_mig_info_h sm;
+	int home_load, remote_load;
+	int kk, temp;
+#endif /*CONFIG_SHM*/
+
 	register struct mosix_task *m = &p->mosix;
 	int mach[MAX_CONSIDERED], aload[MAX_CONSIDERED];
 #ifdef CONFIG_MOSIX_LOADLIMIT
@@ -642,6 +678,10 @@
 	int64_t ms;
 	struct aload_h a;
 
+#ifdef CONFIG_SHM
+	for(l = 0; l < 10; l++)
+		override_arr[l] = -1;
+#endif /*CONFIG_SHM*/
 	if((m->stay & DSTAY) || !PE || mosadmin_mode_quiet)
 		goto out;
 	if(reason && (m->stay || mosadmin_mode_stay ||
@@ -838,6 +878,7 @@
 #endif /* CONFIG_MOSIX_FS */
 	if(n == 0 || (n == 1 && mach[0] == 0))
 		goto out;	/* save time */
+	
 #ifdef CONFIG_MOSIX_FS
 	/* prepare the MFS mapping */
 	if(mfs_tot)
@@ -1031,8 +1072,42 @@
 		{
 			ask_deputy_to_goto(k);
 		}
+#ifdef CONFIG_SHM
+                else
+		{
+			temp = get_shmid(p->pid);
+			shm = get_shmeminfo(p->pid);
+			if(shm)
+			{
+				if((shm->shm_owner != PE) && (k != shm->shm_owner))
+				{
+					kk = shm->shm_owner;
+					if((loadinfo[get_index_loadinfo(kk)].load)  <= (loadinfo[get_index_loadinfo(PE)].load + 150 ))
+						psret = passto(kk, reason);
+				}
+				else
+					psret = passto(k, reason);
+			}	  
+			else
+				psret = passto(k, reason);
+						
+			if(!psret && (p->mosix.mig_flags & OVERRIDE))
+			{ 
+				/* Send all nodes the new owner of shared 
+				 * memory 
+				 */
+				sm.shmid = temp;
+				sm.new_owner = k;
+				sm.home_node = PE;
+				mig_shm_sendmsg(SHM_OWNER_BROADCAST, &sm, sizeof(struct shm_mig_info_h), -1, 1);
+			}
+			if(!psret)
+				goto out;
+		} /* end of if(remote) */
+#else
 		else if(passto(k, reason) == 0)
 			goto out;
+#endif /* CONFIG_SHM */
 		/* conditions changed meanwhile? */
 		if(mosadmin_mode_quiet || (reason && (mosadmin_mode_stay ||
 			(mosadmin_mode_lstay && !(m->dflags & DREMOTE)))))
diff -urNa openMosix-2.4.21/hpc/deputy.c Migshm-2.4.21/hpc/deputy.c
--- openMosix-2.4.21/hpc/deputy.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/deputy.c	2003-07-12 12:05:59.000000000 +0530
@@ -6,8 +6,12 @@
  *
  * Author(s): Moshe Bar, Amnon Shiloh
  */
-
-
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/sched.h>
 #include <linux/ptrace.h>
@@ -29,6 +33,9 @@
 #ifdef CONFIG_MOSIX_DFSA
 #include <hpc/dfsa.h>
 #endif /* CONFIG_MOSIX_DFSA */
+#ifdef CONFIG_SHM
+#include<mig_shm/thread.h>
+#endif /*CONFIG_SHM*/
 
 static inline int
 HAS_ASYNC(struct task_struct *p)
@@ -384,12 +391,16 @@
 		return(type);
 	else if(type & ANYTIME)
 	{
+#ifdef CONFIG_SHM
+		if( type == REM_WRITEBACK ) 
+			return(0);
+#endif /* CONFIG_SHM */
 		if((err = deputy_handle_interim_request(type, *head, *hlen)))
 			return(err);
 	}
 	else
 	{
-		printk("DEPUTY: Unexpected non-urgent request type %x\n", type);
+		printk("%d-DEPUTY: Unexpected non-urgent request type %x\n",current->pid, type);
 		mosix_panic("deputy_wait");
 		comm_free(*head);
 		comm_flushdata(COMM_ALLDATA);
@@ -979,7 +990,10 @@
 	if(page)
 	{
 		kunmap(page);
+#ifndef CONFIG_SHM
+/* We do not want to free the pages on home node. */
 		__free_page(page);
+#endif /* CONFIG_SHM */
 	}
 	return(err);
 }
diff -urNa openMosix-2.4.21/hpc/freemem.c Migshm-2.4.21/hpc/freemem.c
--- openMosix-2.4.21/hpc/freemem.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/freemem.c	2003-07-12 12:05:59.000000000 +0530
@@ -6,6 +6,12 @@
  *
  * Author(s): Amnon Shiloh, Moshe Bar
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/sched.h>
 #include <linux/mm.h>
@@ -21,6 +27,10 @@
 #include <hpc/debug.h>
 #include <hpc/defs.h>
 #include <hpc/balance.h>
+#ifdef CONFIG_SHM
+#include<mig_shm/log_info.h>
+#include<asm/pgtable.h>
+#endif /*CONFIG_SHM*/
 
 int pages_to_keep_free;
 int latest_free_mem;
@@ -189,19 +199,27 @@
  * sort pages into 3 piles: "used", "unused" and "swapped"
  * plus another distinction for unused pages not otherwise accounted for
  */
+#ifdef CONFIG_SHM
+void
+sort_and_age_pages(struct mm_struct *mm, pid_t pid)
+#else
 void
 sort_and_age_pages(struct mm_struct *mm)
+#endif /*CONFIG_SHM*/
 {
 	int used = 0, unused = 0, swapped = 0, private_unused = 0;
 	int need_flush = 0;
-	register struct vm_area_struct *vma;
+	register struct vm_area_struct *vma = NULL;
 	pgd_t *pgdir;
 	pmd_t *pmdir;
-	pte_t *pte;
+	pte_t *pte = NULL;
 	struct page *page;
 	unsigned long addr, start, pgd_end, pmd_end;
 	static int let_go = -1;
 	int interval = sort_interval(1);
+#ifdef CONFIG_SHM
+	struct task_struct* q = NULL;
+#endif /*CONFIG_SHM*/
 
 	if(!mm->last_memsort && interval)
 	{
@@ -228,8 +246,10 @@
 			if(let_go-- == 0)
 			{
 				spin_unlock(&mm->page_table_lock);
+				neutralize_my_load(1);
 				current->policy |= SCHED_YIELD;
 				schedule();
+				neutralize_my_load(0);
 				goto loop;
 			}
 			pgd_end = (addr + PGDIR_SIZE) & PGDIR_MASK;
@@ -247,8 +267,10 @@
 					continue;
 				pte = pte_offset(pmdir, addr);
 					page = pte_page(*pte);
+				
 				for(; addr < pmd_end ; addr += PAGE_SIZE, pte++)
 	{
+					
 		if(pte_none(*pte))
 			continue;
 		if(!pte_present(*pte))
@@ -259,37 +281,41 @@
 		page = pte_page(*pte);
 		if(!VALID_PAGE(page) || PageReserved(page))
 			continue;
-		if(PageActive(page))
+					
+					if(ptep_test_and_clear_young(pte))
 		{
+						page->young = 1;
+						page->last_young = jiffies;
 			used++;
-			continue;
+						mark_page_accessed(page);
+#ifdef CONFIG_SHM
+						q = find_any_task_by_pid(pid);
+						if(q && (q->mosix.mig_flags & IF_SHMAT) && !(q->mosix.dflags & DDEPUTY))
+		{
+							if(pte_dirty(*pte))
+								log_access(pid,vma->vm_start, 1);
+							else 
+								log_access(pid, vma->vm_start, 0);
 		}
-		if(!PageActive(page))
-		{
-			unused++;
-			continue;
-		}
-		if(time_before(jiffies, page->last_young + OLD_SECONDS * HZ))
-		{
-			used++;
+#endif /*CONFIG_SHM*/
 			continue;
 		}
-		if(ptep_test_and_clear_young(pte))
+					if(PageActive(page) || (page->young && time_before(jiffies,
+											   page->last_young + OLD_SECONDS * HZ)))
 		{
-			page->young = 1;
-			page->last_young = jiffies;
-			need_flush = 1;
 			used++;
 			continue;
 		}
 		unused++;
+					if(!PageLRU(page))
 		private_unused++;
-	}
-			}
-		}
-	}
-	if(need_flush)
-		flush_tlb_mm(mm);
+				}//end of pte++ loop
+				
+			}//end of pmd++loop
+			
+		}//end of pgdir++ loop	
+		
+	}//end of vma loop
 	spin_unlock(&mm->page_table_lock);
 	write_lock_irq(&tasklist_lock);
 	mm->used = used;
@@ -313,6 +339,14 @@
 	unsigned need_increase = 0;
 	int interval;
 
+#ifdef CONFIG_SHM
+	pid_t pid[100];
+	int fcount = 0;
+	
+	for(i = 0; i < 100; i++)
+		pid[i] = -1;
+#endif /*CONFIG_SHM*/
+
 	common_daemon_setup("memsorter", 0);
 	neutralize_my_load(1);
 	if(!(mms = (struct mm_struct **)kmalloc(mmno * sizeof(mms[0]),
@@ -339,6 +373,14 @@
 		loop:
                 if (!PE)
 			wait_for_mosix_configuration(NULL);
+#ifdef CONFIG_SHM
+		fcount++;
+		if(fcount == 100)
+		{
+			flush_counts();
+			fcount = 0;
+		}
+#endif /* CONFIG_SHM */
 		if(mosadmin_mode_quiet)
 			continue;
 		compute_freemem();
@@ -360,18 +402,31 @@
 				else
 				{
 					atomic_inc(&mm->mm_users);
-					mms[n++] = mm;
+					mms[n] = mm;
+#ifdef CONFIG_SHM
+					pid[n] = p->pid;
+#endif /*CONFIG_SHM*/
+					n++;
 					mm->mark = marker;
 				}
 			}
 			task_unlock(p);
+			
 		}
 		write_unlock_irq(&tasklist_lock);
 		for(i = 0 ; i < n ; i++)
 		{
 			mm = mms[i];
 			if(atomic_read(&mm->mm_realusers) > 0)
+			{
+#ifdef CONFIG_SHM			
+			 maask_flag = 1;
+		         sort_and_age_pages(mm, pid[i]);
+			 maask_flag = 0;
+#else
 				sort_and_age_pages(mm);
+#endif /*CONFIG_SHM*/		
+			}
 			mmput(mm);
 		}
 		if(need_increase)
@@ -427,7 +482,14 @@
 	sti();
 	before = jiffies;
 	for(i = 0 ; i < 1000 ; i++)
+	{
+#ifdef CONFIG_SHM
+	  maask_flag = 0;
+	  sort_and_age_pages(mm, -1);
+#else
 		sort_and_age_pages(mm);
+#endif /*CONFIG_SHM */
+	}
 	milli = (jiffies - before) * 1000 / HZ;
 	printk("%d miliseconds, ", milli);
 	sort_age_maxchunk = sv;
diff -urNa openMosix-2.4.21/hpc/init.c Migshm-2.4.21/hpc/init.c
--- openMosix-2.4.21/hpc/init.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/init.c	2003-07-12 12:05:59.000000000 +0530
@@ -11,6 +11,13 @@
 /*
  * Author(s): Amnon Shiloh, Moshe Bar
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
 #include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/mm.h>
@@ -25,6 +32,9 @@
 #ifdef CONFIG_MOSIX_DFSA
 #include <hpc/dfsa.h>
 #endif /* CONFIG_MOSIX_DFSA */
+#ifdef CONFIG_SHM
+#include <mig_shm/shm_comm.h>
+#endif /* CONFIG_SHM */
 
 #define	STD_LOOPS	9961472  /* loops per jiffy on standard processor */
 
@@ -49,4 +59,7 @@
 	mosinfo_update_gateways();
 	kernel_thread(mosix_info_daemon, NULL, 0);
 	kernel_thread(mosix_mem_daemon, NULL, 0);
+#ifdef CONFIG_SHM
+	kernel_thread(mig_shm_daemon, NULL, 0);
+#endif /* CONFIG_SHM */
 }
diff -urNa openMosix-2.4.21/hpc/kernel.c Migshm-2.4.21/hpc/kernel.c
--- openMosix-2.4.21/hpc/kernel.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/kernel.c	2003-07-12 12:05:59.000000000 +0530
@@ -11,6 +11,13 @@
 /*
  * Author(s): Amnon Shiloh.
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
 #include <linux/sched.h>
 #include <linux/hpcctl.h>
 #include <linux/hpc.h>
@@ -806,7 +813,9 @@
 			task_maps_ip(p, ip))
 		{
 			task_lock(p);
+#ifndef CONFIG_SHM 
 			p->mosix.stay |= DSTAY_FOR_MONKEY;
+#endif /* CONFIG_SHM */
 			task_unlock(p);
 			if(p->mosix.dflags & DDEPUTY)
 			{
@@ -884,8 +893,12 @@
 	{
 		if(atomic_read(&mm->mm_kiocount))
 			stay |= DSTAY_FOR_KIOBUF;
+#ifdef CONFIG_SHM
+		if(!(current->mosix.mig_flags & MIG_CLONE))
+#endif /* CONFIG_SHM */
 		if(atomic_read(&mm->mm_realusers) > 1)
 			stay |= DSTAY_FOR_CLONE;
+
 		if(mm->def_flags & VM_LOCKED)
 			stay |= DSTAY_FOR_MLOCK;
 		for(mpnt = mm->mmap ; mpnt ; mpnt = mpnt->vm_next)
@@ -896,8 +909,10 @@
 
 				ip = mpnt->vm_file->f_dentry->d_inode;
 				mode = ip->i_mode;
+#ifndef CONFIG_SHM
 				if(ip->i_mapping->i_mmap_shared)
 					stay |= DSTAY_FOR_MONKEY;
+#endif /* CONFIG_SHM */
 				if(S_ISCHR(mode) || S_ISFIFO(mode) ||
 								S_ISSOCK(mode))
 					stay |= DSTAY_FOR_DEV;
diff -urNa openMosix-2.4.21/hpc/mig.c Migshm-2.4.21/hpc/mig.c
--- openMosix-2.4.21/hpc/mig.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/mig.c	2003-07-12 12:05:59.000000000 +0530
@@ -6,8 +6,12 @@
  *
  * Author(s): Oren Laadan, Amnon Shiloh, Moshe Bar
  */
-
-
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/sched.h>
 #include <linux/ptrace.h>
@@ -36,6 +40,15 @@
 #include <linux/module.h>
 #include <asm/processor.h>
 #include <asm/i387.h>
+#ifdef CONFIG_SHM
+#include <linux/shm.h>
+#include <mig_shm/log_info.h>
+#include <mig_shm/sync.h>
+#include <hpc/hpctask.h>
+#include <linux/pagemap.h>
+#include <mig_shm/thread.h>
+#include <mig_shm/shm_comm.h>
+#endif/*CONFIG_SHM*/
 #ifdef CONFIG_MOSIX_DFSA
 #include <hpc/dfsa.h>
 #endif /* CONFIG_MOSIX_DFSA */
@@ -63,6 +76,11 @@
 #define	SHOW_MIGRATIONS	1
 #endif /* CONFIG_MOSIX_WEEEEEEEEE */
 #endif /* CONFIG_MOSIX_UDB */
+#ifdef CONFIG_SHM
+#define for_each_remote_task(p) \
+        for (p = &init_task ; (p = p->next_task) != &init_task ; ) \
+                if(p->mosix.dflags & DREMOTE)
+#endif /* CONFIG_SHM */
 
 int
 mosix_mig_daemon(void *dummy)
@@ -151,6 +169,11 @@
 	int error;
 	int reply = 0;
 	unsigned int load_came_in = 0;
+#ifdef CONFIG_SHM
+	int found = 0;
+        struct mm_struct* mm, *active_mm;
+        struct task_struct* q;
+#endif /*CONFIG_SHM*/
 
 	memcpy(p->comm, REMOTESTR, sizeof(REMOTESTR));
 	p->mosix.stay = 0;
@@ -164,6 +187,49 @@
 		p->mosix.dflags |= DPSYNC;
 	if ((error = mig_recv_request(&mrp)))
 		goto failed;
+#ifdef CONFIG_SHM
+        if(mrp->is_clone && !mrp->mm_to_be_sent )
+	{
+		p->mosix.mig_flags |= MIG_CLONE;
+
+		/* If a sibling already exists here, I will use the same mm */
+		for_each_task(q)
+			{
+			  task_lock(q);
+				if( (q->mosix.ppid == mrp->ppid) && (q->mosix.deppe == current->mosix.deppe) && (q != current) )
+				{
+					task_lock(p);
+					mm = p->mm;
+					p->mm = q->mm;
+					mmdrop(mm);
+					active_mm = p->active_mm;
+					p->active_mm = q->mm;
+					activate_mm(active_mm, q->mm);
+					if(active_mm != q->mm)
+						mmdrop(active_mm);
+					mm = p->mm;
+					task_unlock(p);
+					/* unlock sibling q... locked in 
+					 * mig_recv_request() 
+					 */
+					task_unlock(q);
+					atomic_inc(&mm->mm_realusers);
+					atomic_inc(&mm->mm_users);
+					found = 1;
+					break;
+				}
+				task_unlock(q);
+			}
+		if( !found )
+		{
+			goto failed;
+		}
+	}
+	else
+		current->mosix.mig_flags &= ~MIG_CLONE;
+
+#endif /*CONFIG_SHM*/
+
 	type = mrp->request_type;
 	if(type != DEPUTY_PROBE)
 		load_came_in = 1;
@@ -237,6 +303,9 @@
 	if(SHOW_MIGRATIONS)
 		printk("Weeeeeeeee.....\n");
 #endif /* SHOW_MIGRATIONS */
+#ifdef CONFIG_SHM_DEBUG
+	printk("\n--%d from %d: Weeeeeeeee on REMOTE ..... %d here on %d\n", current->mosix.mypid,current->mosix.deppe, current->pid, PE);
+#endif /* CONFIG_SHM_DEBUG */
 	kickstart();
 	panic("kickstart returned");
 	/*NOTREACHED*/
@@ -402,6 +471,30 @@
 	int error;
 	int len;
 
+#ifdef CONFIG_SHM
+	int peer;
+	struct task_struct* q;
+ 
+	mrp.mm_to_be_sent = 1;
+	if( current->mosix.mig_flags & MIG_CLONE )
+	{
+		/* Flag the arrival of a clone */
+		mrp.is_clone = 1;
+		mrp.ppid = current->mosix.ppid;
+		peer = comm_getpeer(current->mosix.contact);
+	
+		for_each_task(q)
+		  {
+		    if(  ( (current->mosix.dflags & DDEPUTY) && (q != current) && (q->mosix.ppid == current->mosix.ppid) && (q->mosix.whereami == peer )) )
+		      {
+			      mrp.mm_to_be_sent = 0;
+			      break;
+		      }
+		  }
+	}
+	else
+		mrp.is_clone = 0;
+#endif /*CONFIG_SHM*/
 	mrp.version = MOSIX_MIGRATION_VERSION;
 	mrp.topology = MAX_MOSIX_TOPOLOGY;
 	mrp.reason = reason;
@@ -446,6 +539,11 @@
 {
 	int type, hlen;
 	int reply = -EDIST;
+#ifdef CONFIG_SHM
+        int found = 0;
+        struct task_struct* q;
+	struct mm_struct* mm;
+#endif /*CONFIG_SHM*/
 
 	if ((type = comm_recv((void **) mrp, &hlen)) < 0)
 		return (type);
@@ -495,6 +593,36 @@
 			current->mosix.pages_i_bring = (*mrp)->pages_sent;
 		}
 
+/*
+ * If the thread wants to migrate home and there is no parent on the home, 
+ * then stop the thread from migrating. 
+ */
+#ifdef CONFIG_SHM
+        if( (*mrp)->is_clone )
+	{
+		for_each_task(q)
+			{
+				task_lock(q);
+				if( (q->pid == (*mrp)->ppid) && (current->mosix.dflags & DDEPUTY) )
+				  {
+				    /* q unlocked only after its remote 
+					 * sibling comes here... 
+					 * in mig_remote_receive_proc()
+					 */
+				  task_unlock(q);
+					 mm = q->mm;
+					 found = 1;
+					 break;
+				}
+				task_unlock(q);
+			}
+		if( !found && !(current->mosix.dflags & DREMOTE) )
+		{
+			goto failed;
+		}
+	}
+#endif /*CONFIG_SHM*/
+ 
 	return (0);
 
  failed:
@@ -518,6 +646,10 @@
 	struct mosix_link *mlink;
 	int error;
 	int omigpages;
+#ifdef CONFIG_SHM
+	struct task_struct *q;
+	struct mm_struct* mm;
+#endif /* CONFIG_SHM */
 
 	if(!p->mosix.held_files && (error = mosix_rebuild_file_list()))
 		return(error);
@@ -568,6 +700,22 @@
 	p->mosix.migpages = omigpages;
 
 	deputy_startup();
+
+#ifdef CONFIG_SHM
+	if(current->mosix.mig_flags & MIG_CLONE)
+	{
+		mm  = current->p_pptr->mm;
+		if(mm && current->p_pptr->mosix.mig_flags & MIG_CLONE )
+		{
+			if(atomic_read(&mm->mm_realusers))
+				/* We expect that the parent doesn't 
+				 * terminate 
+				 */
+				atomic_dec(&mm->mm_realusers);
+		}
+	}
+#endif /*CONFIG_SHM*/
+
 	return (0);
 
  failed:
@@ -592,6 +740,10 @@
 	long orlim_rss;
 	long orlim_stack;
 	unsigned int load_came_in = 0;
+#ifdef CONFIG_SHM
+        struct mm_struct* mm, *active_mm;
+        struct task_struct* q;
+#endif /*CONFIG_SHM*/
 
 	mosix_deputy_rusage(0);
 	if(obtain_mm())
@@ -618,6 +770,35 @@
 	if ((error = mig_recv_request(&mrp)))
 		goto fail;
 	load_came_in = 1;
+#ifdef CONFIG_SHM
+        if(mrp->is_clone)
+	{
+		p->mosix.mig_flags |= MIG_CLONE;
+		for_each_task(q)
+			{
+				task_lock(q);
+				if( q->pid == mrp->ppid )
+				{
+					task_lock(p);
+
+					mm = p->mm;
+					p->mm = q->mm;
+					mmdrop(mm);
+					active_mm = p->active_mm;
+					p->active_mm = q->mm;
+					activate_mm(active_mm, q->mm);
+					if(active_mm != q->mm)
+						mmdrop(active_mm);
+					mm = p->mm;
+					task_unlock(p);
+					atomic_inc(&mm->mm_realusers);
+					atomic_inc(&mm->mm_users);
+				}
+				task_unlock(q);
+			}
+	}
+
+#endif /*CONFIG_SHM*/
 	comm_free((void *) mrp);
 	if ((error = comm_send(MIG_REQUEST|REPLY, (void *)&error, sizeof(int),
 						   NULL, 0, 0))) {
@@ -635,6 +816,9 @@
 		if(SHOW_MIGRATIONS)
 			printk("Wooooooooo.....\n");
 #endif /*SHOW_MIGRATIONS*/
+#ifdef CONFIG_SHM_DEBUG
+			printk("\n--%d Wooooooooo back to DEPUTY \n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
 		end_coming_in(0);
 		current->mosix.pages_i_bring = 0;
 		if(p->mosix.dflags & DDELAYHELD)
@@ -844,6 +1028,7 @@
 				{
 					m.fp = NULL;
 					m.pgoff = 0;
+					m.nopage = NULL;
 				}
 			if(comm_send(MIG_MM_AREA, &m, sizeof(m), NULL, 0, 0))
 				return(-1);
@@ -873,6 +1058,42 @@
 	credit = run_over_dirty_pages(mig_send_page, 1);
 	return(credit);
 }
+/* mig_send_shmeminfo- This function sends all shared memory information to be  * inserted into the shared memory structure i.e. shmeminfo on the remote whcih * will become the new logical home ndoe of the memory. The function checks the * OVERRIDE flag and only then sends the info and delets the entry for that 
+ * process from the list on this node 
+ */
+#ifdef CONFIG_SHM
+int
+mig_send_shmeminfo(void)
+{
+
+	struct mig_shm_h mshmhdr;
+	struct shmeminfo* travshm;
+
+	if(current->mosix.mig_flags & IF_SHMAT)
+	{
+		if( (travshm = get_shmeminfo(current->pid)) != NULL )
+		{
+			mshmhdr.shmid = travshm->shmid;
+			if( (mshmhdr.shmaddr = get_shmaddr(current->pid)) < 0)
+			{
+#ifdef CONFIG_SHM_DEBUG
+				printk("%d-mig_send_shmeminfo: Cannot find processinfo\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+				return (-1);
+			}
+			if(current->mosix.dflags & DDEPUTY)
+				mshmhdr.shm_owner = get_shm_owner(mshmhdr.shmid, PE);
+			else
+				mshmhdr.shm_owner = get_shm_owner(mshmhdr.shmid, current->mosix.deppe);
+			remove_processinfo(mshmhdr.shmaddr);
+			return(comm_send(MIG_SHM, &mshmhdr, sizeof(mshmhdr), NULL, 0, 0));
+		}
+		else
+			return(-1);
+	}
+	return(0);
+}
+#endif /*CONFIG_SHM*/
 
 int
 mig_send_fp(void)
@@ -975,13 +1196,21 @@
 	m.pagecredit = credit;
 	m.lastxcpu = p->mosix.last_sigxcpu;
 	sti();
+#ifdef CONFIG_SHM
+	m.mig_flags = p->mosix.mig_flags;
+	m.ppid = p->mosix.ppid;
+	m.start_stack = p->mosix.start_stack;
+	m.nshm = p->mosix.nshm;
+#endif /*CONFIG_SHM*/
 	if(comm_send(MIG_MISC, &m, sizeof(m), forced_sigs,
 				 m.asig.nforced * sizeof(siginfo_t), 0))
 		goto fail;
 	comm_migration_mode(0);
 	expel_progress = 1;
 	if(comm_recv(&hd, &hdln) == (MIG_MISC|REPLY))
+	{
 		return(0); /* commit point */
+	}
 
  fail:
 	cli();
@@ -1028,16 +1257,68 @@
 mig_do_send(void)
 {
 	int credit;	/* # of clean demand-pages */
+#ifdef CONFIG_SHM
+        struct task_struct * q;
+        int peer, i;
+        int thread_found = 0;
+#endif /*CONFIG_SHM*/
+ 
         if(current->mm->context.segments)
 		clear_LDT();
 
 	comm_migration_mode(1);
 	neutralize_my_load(1); /* don't count me: I'm going to disappear */
+
+#ifdef CONFIG_SHM
+/*
+ * If a sibling already exists on the remote during thread migration, we need 
+ * to send only the thread's data section, user mode stack and the parent's 
+ * user mode stack.   
+*/
+
+	peer = comm_getpeer(current->mosix.contact);
+	if(current->mosix.mig_flags & MIG_CLONE)
+	{
+		for_each_task(q)
+		{
+			if(  ( (current->mosix.dflags & DDEPUTY) && (q != current) && (q->mosix.ppid == current->mosix.ppid) && (q->mosix.whereami == peer )) || ((current->mosix.dflags & DREMOTE) && (peer == current->mosix.deppe)) )
+			{
+				thread_found = 1;
+#ifdef CONFIG_SHM_DEBUG				       
+				if(current->mosix.mig_flags & MIG_CLONE)
+					printk("%d-mig_do_send: Sibling found on remote.\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+				if(mig_send_misc(0))
+				{
+#ifdef CONFIG_SHM_DEBUG				       
+					printk("%d-mig_do_send: cannot send clone information\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+					return -1;
+				}
+				send_thread_section(current, DATA_SECTION, peer);
+				send_thread_section(current, THREAD_STACK_SECTION, peer);
+				if( current->mosix.dflags & DDEPUTY )
+					send_thread_section(current, PARENT_STACK_SECTION, peer);
+				break;
+			}
+		}
+	}
+	else
+		thread_found = 0;
+
+	if(!thread_found)
+        if(mig_send_mm_stats() || mig_send_mm_areas() ||
+           (credit = mig_send_pages()) < 0 || mig_send_shmeminfo() ||
+	   (current->used_math && mig_send_fp()) ||
+	   (current->mm->context.segments && mig_send_ldt()) ||
+	   mig_send_misc(credit))
+#else
 	if(mig_send_mm_stats() || mig_send_mm_areas() ||
 	   (credit = mig_send_pages()) < 0 ||
 	   (current->used_math && mig_send_fp()) ||
 	   (current->mm->context.segments && mig_send_ldt()) ||
 	   mig_send_misc(credit))
+#endif /* CONFIG_SHM */
 		{
 			comm_send(MIG_NOT_COMING, NULL, 0, NULL, 0, 0);
 			comm_migration_mode(0);
@@ -1071,6 +1352,13 @@
 	unsigned long prot, flags;
 	extern asmlinkage long sys_madvise(unsigned long, size_t, int);
 
+#ifdef CONFIG_SHM
+        struct vm_area_struct* vma;
+
+        if( (m->nopage == (nopage_t)shmem_nopage))
+		flags = MAP_SHARED;
+        else
+#endif /*CONFIG_SHM*/
 	/* unconvert prot+flags: */
 	flags = MAP_FIXED|MAP_PRIVATE;
 	prot = 0;
@@ -1091,6 +1379,21 @@
 	deeper_sleep();
 	result = do_mmap_pgoff(m->fp, m->addr, m->len, prot, flags, m->pgoff);
 	lighter_sleep();
+
+/*
+ * If the vm of the arriving process is a shared memory region, VM_SHARED is
+ * set
+ */
+#ifdef CONFIG_SHM
+
+        if( m->nopage == (nopage_t)shmem_nopage)
+	{
+		vma = find_vma(current->mm, m->addr);
+		if(vma)
+			vma->vm_flags |= VM_SHARED;
+	}
+#endif /*CONFIG_SHM*/
+    
 	if(m->flags & VM_MAYSHARE)
 		current->mosix.dirty_bits &= ~MMAP_MAYSHARE;
 	if(m->flags & VM_READHINTMASK)
@@ -1119,6 +1422,15 @@
 	struct task_struct *p = current, *pp;
 	struct mm_struct *mm = p->mm;
 	int must = (p->mosix.dflags & DMUSTBEBACK);
+#ifdef CONFIG_SHM
+        int file_found = 0;
+        struct task_struct *q;
+        struct vm_area_struct *vm;
+        struct inode *ip;
+        struct shmem_inode_info *info;
+        struct page *old_page;
+#endif /* CONFIG_SHM  */
+
 	static DECLARE_WAIT_QUEUE_HEAD(wait_for_someone_to_give_up);
 
 	if(!(vma = find_vma(mm, addr)))
@@ -1180,9 +1492,62 @@
 			wake_up(&wait_for_someone_to_give_up);
 			stuck_here = 0;
 		}
+#ifdef CONFIG_SHM
+
+		lock_kernel();
+
+#endif /*CONFIG_SHM */
 	if(--p->mosix.pages_i_bring < 0)
+	{
+#ifdef CONFIG_SHM
+		unlock_kernel();
+#endif /*CONFIG_SHM*/
 		mosix_panic("too many pages arrived");
+	}
 	p->mosix.rfreepages--;
+#ifdef CONFIG_SHM
+	unlock_kernel();
+#endif /*CONFIG_SHM*/
+/*
+ * Processes attatched to the same memory region should share the same 
+ * physical pages even on the remote. If the received page is a shared memory
+ * page, find the associated file.If page already exists, don't allocate a new
+ * one here.Just sync the  contents.
+ */
+#ifdef CONFIG_SHM
+        if( (vma->vm_file) && ( p->mosix.dflags & DREMOTE ) )
+	{
+	        for_each_remote_task(q)
+		{
+		task_lock(q);
+		if( q->mm && (q->mosix.dflags & DREMOTE) && (q != p))
+		{
+			for(vm = q->mm->mmap; vm != NULL ;vm = vm->vm_next)
+			{
+				struct inode* inode = NULL;
+				if( (vm->vm_file) && (vm->vm_file == vma->vm_file) )
+				{
+					inode = vm->vm_file->f_dentry->d_inode;
+					if(inode->u.remote_i.nopage == (nopage_t)shmem_nopage)
+					{
+						file_found = 1;
+						task_unlock(q);
+						break;
+					}
+				}
+			}
+		}
+		task_unlock(q);
+		}
+	}
+        else if( (current->mosix.dflags & DDEPUTY ) && (vma->vm_file) && 
+		 (vma->vm_ops->nopage == (nopage_t)shmem_nopage) )
+		file_found = 1;
+        else
+                file_found = 0;
+
+#endif /* CONFIG_SHM */
+ 
 	if(!page && !(page = alloc_page(GFP_HIGHUSER)))
 		{
 			comm_flushdata(COMM_ALLDATA);
@@ -1195,6 +1560,42 @@
 			return(-1);
 		}
 	kunmap(page);
+#ifdef CONFIG_SHM
+        if(file_found)
+	{
+		/* A process attatched to the same memory region is already 
+		 * present here.
+		 */
+		lock_kernel();
+		current->mosix.mig_flags & IF_SHMAT;
+		if( current->mosix.dflags & DDEPUTY )
+		{
+			old_page = shmem_nopage(vma, addr, 1);
+			if(old_page)
+			{
+				memcpy( kmap(old_page), kmap(page), PAGE_SIZE);
+				kunmap(old_page);
+				kunmap(page);
+				__free_page(page);
+				page = old_page;
+			}
+                }
+                else if(current->mosix.dflags & DREMOTE)
+                {
+			old_page = filemap_nopage(vma, addr, 1);
+			if(old_page)
+			{
+				memcpy( kmap(old_page), kmap(page), PAGE_SIZE);
+				kunmap(old_page);
+				kunmap(page);
+				__free_page(page);
+				page = old_page;
+			}
+                }
+		unlock_kernel();
+	}
+#endif /* CONFIG_SHM */
+
 	pgd = pgd_offset(mm, addr);
 	spin_lock(&mm->page_table_lock);
 	if (!(pmd = pmd_alloc(mm, pgd, addr)))
@@ -1219,10 +1620,50 @@
 	set_pte(pte, pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
 	mm->rss++;
 	spin_unlock(&mm->page_table_lock);
+        
+#ifdef CONFIG_SHM
+
+	if(vma->vm_file && (current->mosix.dflags & DREMOTE) && !file_found)
+	{
+	  	lock_kernel();
+
+		ip = vma->vm_file->f_dentry->d_inode;
+		if( (current->mosix.dflags & DREMOTE) && 
+		    (ip->u.remote_i.nopage == (nopage_t)shmem_nopage ))
+		{
+			if(!pte_write(*pte))
+				*pte = pte_mkwrite(*pte);
+
+			add_to_page_cache(page, vma->vm_file->f_dentry->d_inode->i_mapping, ((addr - vma->vm_start) >> PAGE_CACHE_SHIFT)+vma->vm_pgoff);
+			
+			SetPageUptodate(page);
+			if(PageLocked(page))
+				UnlockPage(page);
+			page = pte_page(*pte);
+		}
+		unlock_kernel();
+	}
+#endif /* CONFIG_SHM */
 	flush_page_to_ram(page);
 	return(0);
 }
 
+/* mig_do_receive_shmeminfo - This functuion receives all the shared memory 
+ * info and inserts and entry into teh shared emmory array i.e. shmeminfo for 
+ * this process in this node which is the new home node of the shared memory 
+ * now. 
+ */
+#ifdef CONFIG_SHM
+void
+mig_do_receive_shmeminfo(struct mig_shm_h* mshmhdr)
+{
+	if(current->mosix.dflags & DREMOTE)
+		add_shmeminfo(mshmhdr->shmid, mshmhdr->shm_owner, current->mosix.deppe);
+	else
+		add_shmeminfo(mshmhdr->shmid, mshmhdr->shm_owner, PE);
+	add_processinfo(mshmhdr->shmid, mshmhdr->shmaddr, current->pid);
+}
+#endif /*CONFIG_SHM*/
 void
 mig_do_receive_fp(union i387_union *i)
 {
@@ -1352,6 +1793,13 @@
 	sti();
 	if(p->mosix.dflags & DDEPUTY)
 		deputy_analyse_remote_signals(&m->asig);
+#ifdef CONFIG_SHM
+        p->mosix.ppid = m->ppid;
+        p->mosix.start_stack = m->start_stack;
+	p->mosix.mig_flags |= m->mig_flags;
+	p->mosix.nshm = m->nshm;
+#endif /* CONFIG_SHM */
+
 }
 
 int
@@ -1391,6 +1839,11 @@
 				goto fail;
 			}
 			break;
+#ifdef CONFIG_SHM
+		case MIG_SHM:
+			mig_do_receive_shmeminfo((struct mig_shm_h*)head);
+			break;
+#endif /*CONFIG_SHM*/
 		case MIG_FP:
 			mig_do_receive_fp((union i387_union *)head);
 			break;
@@ -1591,5 +2044,15 @@
 int
 count_migrating_pages(void)
 {
+#ifdef CONFIG_SHM
+	int retval;
+
+	lock_kernel();
+	retval = run_over_dirty_pages(NULL, 0);
+	unlock_kernel();
+
+	return retval;
+#else
 	return(run_over_dirty_pages(NULL, 0));
+#endif /*CONFIG_SHM*/
 }
diff -urNa openMosix-2.4.21/hpc/remote.c Migshm-2.4.21/hpc/remote.c
--- openMosix-2.4.21/hpc/remote.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/remote.c	2003-07-12 12:05:59.000000000 +0530
@@ -6,6 +6,12 @@
  *
  * Author(s): Amnon Shiloh, Moshe Bar
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 
 #include <linux/sched.h>
@@ -32,6 +38,16 @@
 #include <linux/file.h>
 #include <hpc/balance.h>
 #include <hpc/dfsa.h>
+#ifdef CONFIG_SHM
+#include <mig_shm/sync.h>
+#include <mig_shm/log_info.h>
+#include <linux/shm.h>
+#include <linux/highmem.h>
+#include <asm/ipc.h>
+#include <asm/page.h>
+#include <mig_shm/shm_comm.h>
+#include <mig_shm/thread.h>
+#endif /* CONFIG_SHM */ 
 
 int
 remote_wait(int expect, void **head, int *hlen)
@@ -49,6 +65,50 @@
 			inform_deputy_of_urgent();
 		if((type = comm_recv(head, hlen)) < 0)	/* an error */
 			return(type);
+#ifdef CONFIG_SHM
+                if(type == REM_SHMAT)
+                {
+                        struct shm_at_h *data;
+                        struct shmeminfo* travshm = NULL;
+                        data = (struct shm_at_h*)*head;
+
+			if(current->mosix.nshm == 0)
+				current->mosix.mig_flags |= IF_SHMAT; 
+			else
+				current->mosix.mig_flags &= ~IF_SHMAT;
+			current->mosix.nshm++;
+			if(!(travshm = get_shmeminfo(current->pid)))
+                                add_shmeminfo(data->shmid, data->shm_owner, data->shm_home);
+                        add_processinfo(data->shmid, data->shmaddr, current->pid);
+                        comm_free(*head);
+                        *head = NULL;
+                        comm_send(REM_WRITEBACK, NULL, 0, NULL, 0, 0);
+                        current->mosix.dflags |= DPSYNC;
+                        continue;
+                }
+                else if( type == DEP_WRITEBACK )
+                {
+			if(current->mosix.mig_flags & IF_SHMAT)
+			{
+				if(writeback_all())
+				{
+#ifdef CONFIG_SHM_DEBUG
+					printk("%d-remote_wait: Error in writeback_all\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+					return(-1);
+				}
+			}
+			/* A migrated thread wants to sync the data section */
+			if( (current->mosix.mig_flags & MIG_CLONE) && 
+			   !(current->mosix.mig_flags & CLONE_VFORK) )
+				send_thread_section(p, DATA_SECTION, -1);
+			p->mosix.dflags |= DPSYNC;
+                        comm_send(REM_WRITEBACK, NULL, 0, NULL, 0, 0);
+                        type = 0;
+                        continue;
+                }
+#endif /*CONFIG_SHM*/
+
 		if(expect == DEP_USERMODE)
 		/* after migration from REMOTE to REMOTE, certain "replies"
 		 * can arrive as a result from the original call.
@@ -261,10 +321,10 @@
 			break;
 #endif /* CONFIG_MOSIX_DFSA */
 		default:
-			printk("openMosix: remote type %x unexpected\n", type);
+			printk("%d- openMosix: remote type %x unexpected\n",p->pid, type);
 
 			if(type != MIG_REQUEST)
-				mosix_panic("deputy_wait");
+				mosix_panic("remote_wait");
 			return(-EINVAL);
 		}
 		if(error)
@@ -388,6 +448,17 @@
 NORET_TYPE void
 remote_disappear(void)
 {
+#ifdef CONFIG_SHM
+	 struct mm_struct* mm;
+	 if( current->mosix.mig_flags & MIG_CLONE )
+	 {
+		 mm = current->mm;
+		 if ( mm && (atomic_read(&mm->mm_realusers) > 1) )
+		 {
+			 atomic_dec(&mm->mm_realusers);
+		 }
+	 }
+#endif /*CONFIG_SHM*/
 	do_exit(SIGKILL);
 	/*NOTREACHED*/
 }
@@ -639,9 +710,13 @@
 {
 	unsigned long result;
 	struct file *rf;
-	unsigned long prot, flags;
+	unsigned long prot, flags = 0;
 	extern asmlinkage long sys_madvise(unsigned long, size_t, int);
 
+#ifdef CONFIG_SHM
+        struct vm_area_struct *vm;
+#endif /* CONFIG_SHM */
+
 	if(m->fp)
 	{
 		if(!(rf = get_remote_file(m->origin, m->fp, m->dp, m->uniq,
@@ -655,7 +730,24 @@
 		rf = NULL;
 	/* unconvert prot+flags: */
 	prot = 0;
+/*
+ * If two siblings migrate to the same node or if the migrating process
+ * contains a shared memory mapping, set MAP_SHARED.
+ */
+
 	flags = MAP_PRIVATE;
+#ifdef CONFIG_SHM
+	if((current->mosix.mig_flags & MIG_CLONE) && (m->flags & VM_SHARED))
+		flags = MAP_SHARED;
+	
+        if( m->fp && (m->nopage == (nopage_t)shmem_nopage) )
+        {
+                current->mosix.mig_flags |= IF_SHMAT;
+                flags = MAP_SHARED;
+	}
+
+#endif /*CONFIG_SHM*/
+
 	if(m->fixed)
 		flags |= MAP_FIXED;
 	if(m->flags & VM_GROWSDOWN)
@@ -673,6 +765,22 @@
 	if(m->flags & VM_MAYSHARE)
 		current->mosix.dirty_bits |= MMAP_MAYSHARE;
 	result = do_mmap_pgoff(rf, m->addr, m->len, prot, flags, m->pgoff);
+	if(!result)
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d-remote_mmap:result = NULL\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		goto err;
+	}
+#ifdef CONFIG_SHM
+        if( (m->nopage == (nopage_t)shmem_nopage) && m->fp)
+	{
+		vm = find_vma(current->mm, result);
+		if(vm)
+			vm->vm_flags |= VM_SHARED;
+	}
+#endif /* CONFIG_SHM  */
+
 	if(m->flags & VM_MAYSHARE)
 		current->mosix.dirty_bits &= ~MMAP_MAYSHARE;
 	if(rf && !IS_ERR((const void *)result))
diff -urNa openMosix-2.4.21/hpc/rinode.c Migshm-2.4.21/hpc/rinode.c
--- openMosix-2.4.21/hpc/rinode.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/rinode.c	2003-07-12 12:05:59.000000000 +0530
@@ -6,6 +6,13 @@
  *
  *  Author(s): Amnon Shiloh, Moshe Bar
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
 #include <linux/sched.h>
 #include <hpc/protocol.h>
 #include <hpc/comm.h>
@@ -18,6 +25,11 @@
 #include <hpc/debug.h>
 
 /* REMOTE section: */
+#ifdef CONFIG_SHM
+#define for_each_remote_task(p) \
+        for (p = &init_task ; (p = p->next_task) != &init_task ; ) \
+                if(p->mosix.dflags & DREMOTE)
+#endif /* CONFIG_SHM */
 
 spinlock_t rinode_list_lock = SPIN_LOCK_UNLOCKED;
 
@@ -69,19 +81,40 @@
 	int cng;
 	struct dentry *to_dput = NULL;
 	struct inode *to_iput = NULL;
+#ifdef CONFIG_SHM
+	struct task_struct* p;
+
 
+	for_each_remote_task(p)
+	{
+		for(vma = p->mm->mmap ; vma ; vma = vma->vm_next)
+		if( p != current )
+#else 
 	for(vma = current->mm->mmap ; vma ; vma = vma->vm_next)
+#endif /* CONFIG_SHM */ 
 	if((f = vma->vm_file) && home_file(f) == fpr)
 	{
 		ip = f->f_dentry->d_inode;
-		if(ip->u.remote_i.origin == origin && ip->u.remote_i.dp == dpr
+				if(ip && ip->u.remote_i.origin == origin && ip->u.remote_i.dp == dpr
 			&& ip->u.remote_i.unique == uniq && ip->i_size == isize
 			&& ip->u.remote_i.nopage == nopage)
 		{
 			get_file(f);
+#ifdef CONFIG_SHM
+					/* If there exists another process on 
+					 * the remote attatched to the same 
+					 * memory region, a new file should 
+					 * not be allocated. 
+					 */
+					if(nopage == (nopage_t)shmem_nopage)
+						current->mosix.mig_flags |= REM_FILE_SHARED;
+#endif /* CONFIG_SHM */
 			return(f);
 		}
 	}
+#ifdef CONFIG_SHM
+	}
+#endif /* CONFIG_SHM */
 	if(!(f = get_empty_filp()))
 		return(NULL);
 	spin_lock(&dcache_lock);
@@ -206,6 +239,12 @@
 static int
 mosix_remote_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
+#ifdef CONFIG_SHM
+	struct inode* ip;
+	ip = file->f_dentry->d_inode;
+
+	if( (ip->u.remote_i.nopage != (nopage_t)shmem_nopage) && !(current->mosix.mig_flags & MIG_CLONE) )
+#endif /*CONFIG_SHM*/
 	if (vma->vm_flags & VM_SHARED)
 		panic("REMOTE VM_SHARED mmap");
 	vma->vm_ops = &rinode_mmap;
@@ -488,6 +527,7 @@
 			break;
 		if(vmb == vma)
 		{
+#ifndef CONFIG_SHM
 			if(this->f_dentry->d_inode->i_mapping->i_mmap_shared)
 			{
 				monkey:
@@ -495,6 +535,7 @@
 				tell_process(p, DREQ_CHECKSTAY);
 				return(-EDIST);
 			}
+#endif /* CONFIG_SHM */
 			n++;
 		}
 	}
@@ -542,9 +583,12 @@
 		kfree(old);
 	}
 	/* final race check: has any file been made monkey meanwhile? */
+#ifndef CONFIG_SHM
 	for(i = 0 ; i < n ; i++)
 	if(hf[i].f->f_dentry->d_inode->i_mapping->i_mmap_shared)
 		goto monkey;
+#endif /* CONFIG_SHM */
+
 	return(0);
 }
 
diff -urNa openMosix-2.4.21/hpc/syscalls.c Migshm-2.4.21/hpc/syscalls.c
--- openMosix-2.4.21/hpc/syscalls.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/hpc/syscalls.c	2003-07-12 12:05:59.000000000 +0530
@@ -11,6 +11,13 @@
 /*
  * Author(s): Moshe Bar, Amnon Shiloh.
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
 #include <linux/sched.h>
 #include <linux/hpc.h>
 #include <linux/timex.h>
@@ -1551,7 +1558,8 @@
 
 	set_write_region(ARG(1), 6 * sizeof(int));
 	if(!copy_from_user(a, (char *)ARG(1), 6 * sizeof(int)))
-		switch(ARG(0)) {
+		switch(ARG(0))
+		{
 		case SYS_BIND:
 		case SYS_CONNECT:
 			set_write_region(a[1], a[2]);
@@ -1750,6 +1758,10 @@
 
 	switch (call)
 	{
+#ifdef CONFIG_SHM
+        case SHMDT:
+		return(sys_shmdt((char*)ARG(4)));
+#endif /* CONFIG_SHM */
 	case SEMOP:
 		set_write_region(ARG(4), ARG(2)*sizeof(struct sembuf));
 		break;
@@ -2491,3 +2503,11 @@
 #endif /* CONFIG_MOSIX_DFSA */
 	return(remote_standard_system_call(n, &regs));
 }
+#ifdef CONFIG_SHM
+long
+remote_sys_flush( int n, struct pt_regs regs)
+{
+	extern asmlinkage long sys_flush(void);
+	return sys_flush();
+}
+#endif /* CONFIG_SHM */
diff -urNa openMosix-2.4.21/include/asm-i386/unistd.h Migshm-2.4.21/include/asm-i386/unistd.h
--- openMosix-2.4.21/include/asm-i386/unistd.h	2002-11-29 05:23:15.000000000 +0530
+++ Migshm-2.4.21/include/asm-i386/unistd.h	2003-07-12 12:05:59.000000000 +0530
@@ -258,6 +258,11 @@
 #define __NR_free_hugepages	251
 #define __NR_exit_group		252
 
+#ifdef CONFIG_SHM
+#define __NR_printlogs          253
+#define __NR_flush              254
+#endif /* CONFIG_SHM */
+
 /* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */
 
 #define __syscall_return(type, res) \
diff -urNa openMosix-2.4.21/include/hpc/hpctask.h Migshm-2.4.21/include/hpc/hpctask.h
--- openMosix-2.4.21/include/hpc/hpctask.h	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/include/hpc/hpctask.h	2003-07-12 12:05:59.000000000 +0530
@@ -152,6 +152,19 @@
 #ifdef CONFIG_MOSIX_DIAG
 	int mig_page_count;
 #endif /* CONFIG_MOSIX_DIAG */
+#ifdef CONFIG_SHM
+	short int mig_flags; /* Used to indicate events associated with 
+			      * migration decisions for sending the shared 
+			      * memory alongwith the process 
+			      */
+	pid_t ppid;          /* pid of the parent for identifying remote 
+			      * siblings */
+	unsigned long start_stack; /* start of the thread's user mode stack */
+	int nshm;            /* no of shared memories to which the process is 
+			      * is attached 
+		      */
+#endif /*CONFIG_SHM*/
+
 };
 
 #ifdef CONFIG_MOSIX_DFSA
@@ -284,6 +297,17 @@
 #define	MFSBALANCE	(-5)	/* must go back home */
 #define	MUSTGOHOME	(-6)	/* must go back home */
 
+#ifdef CONFIG_SHM
+
+#define OVERRIDE                0x01    /* migrate shared memory - 00000001*/
+#define IF_SHMAT                0x02    /* done shmat - 00000010 */
+#define REM_FILE_SHARED         0x08    /* one of the two remote processes
+                                         * sharing the file on remote- 00001000                                         */
+#define WRITER                  0x10    /* if the process is a writer- 00100000                                         */
+#define MIG_CLONE               0x20
+
+#endif /* CONFIG_SHM */
+
 #define	evaluate_pending_signals_in_mosix_context() do { \
 	struct task_struct *p = current; \
 	unsigned long flags; \
diff -urNa openMosix-2.4.21/include/hpc/protocol.h Migshm-2.4.21/include/hpc/protocol.h
--- openMosix-2.4.21/include/hpc/protocol.h	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/include/hpc/protocol.h	2003-07-12 12:05:59.000000000 +0530
@@ -13,7 +13,9 @@
 #include <linux/signal.h>
 #include <linux/resource.h>
 #include <linux/elf.h>
-
+#ifdef CONFIG_SHM
+#include <linux/types.h>
+#endif /*CONFIG_SHM*/
 #define	EDIST	EDOM	/* MOSIX general error-code, that is otherwise */
 			/* rarely-if-ever returned by kernel */
 
@@ -34,6 +36,11 @@
 	int pages_sent;
 	int request_type;
 	int has_dfsa;
+#ifdef CONFIG_SHM
+        int is_clone;
+        pid_t ppid;
+        int mm_to_be_sent;
+#endif /*CONFIG_SHM*/
 };
 
 enum contact_type
@@ -347,6 +354,12 @@
 	u64 tscval;
 	struct opcost depcost[MAX_MOSIX_TOPOLOGY];
 	int depspeed;
+#ifdef CONFIG_SHM
+	int mig_flags;
+	pid_t ppid;
+        unsigned long start_stack;
+	int nshm;
+#endif /* CONFIG_SHM */
 };
 
 struct decay_h
@@ -447,6 +460,11 @@
 #define	DEP_DFSA_CLEAR		(DEP_FLG|0x81)
 #define	DEP_READ_YOURSELF	(DEP_FLG|0x82)
 #endif /* CONFIG_MOSIX_DFSA */
+#ifdef CONFIG_SHM
+#define DEP_WRITEBACK           (DEP_FLG|0x83)
+#define DEP_REPLY               (DEP_FLG|0x84)
+#endif /* CONFIG_SHM */
+
 
 #define	REM_NOTHING		(ANYTIME|0x01)
 #define	REM_PAGE		(ANYTIME|DFSA_NOUPDATE|0x02)
@@ -455,6 +473,10 @@
 #define	REM_GETALOAD		(ANYTIME|0x05)
 #define	REM_GETTSC		(ANYTIME|0x06)
 
+#ifdef CONFIG_SHM
+#define REM_WRITEBACK           (ANYTIME|0x07)
+#endif /*CONFIG_SHM*/
+
 #define	REM_NULLMSG		0x01
 #define	REM_ASIG		0x02
 #define	REM_SYSCALL_TRACE	0x03
@@ -465,6 +487,10 @@
 #define	REM_MUST_COME_HOME	0x08
 #define	REM_CONNECT_TO		0x09
 
+#ifdef CONFIG_SHM
+#define REM_SHMAT               0x0B /* synching a page from remote to deputy*/
+#endif/*CONFIG_SHM*/
+ 
 #define MIG_REQUEST		(MIG_FLG|0x01)
 
 #define	MIG_MM_STATS		(MIG_FLG|0x10)
@@ -475,6 +501,9 @@
 #define	MIG_LDT			(MIG_FLG|0x15)
 #define	MIG_MISC		(MIG_FLG|0x16)
 #define	MIG_NOT_COMING		(MIG_FLG|0x17)
+#ifdef CONFIG_SHM
+#define MIG_SHM                 (MIG_FLG|0x18) /* The shmeminfo to be sent */
+#endif /*CONFIG_SHM*/
 
 /* routines on the DEPUTY side of the protocol: */
 
diff -urNa openMosix-2.4.21/include/linux/printlogs.h Migshm-2.4.21/include/linux/printlogs.h
--- openMosix-2.4.21/include/linux/printlogs.h	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/include/linux/printlogs.h	2003-07-12 12:05:59.000000000 +0530
@@ -0,0 +1,9 @@
+#ifndef __LINUX_PRINTLOGS_H
+#define __LINUX_PRINTLOGS_H
+
+#include<linux/linkage.h>
+#include<linux/unistd.h>
+
+_syscall0(long, printlogs)
+
+#endif
diff -urNa openMosix-2.4.21/include/linux/shm.h Migshm-2.4.21/include/linux/shm.h
--- openMosix-2.4.21/include/linux/shm.h	2001-11-23 01:16:18.000000000 +0530
+++ Migshm-2.4.21/include/linux/shm.h	2003-07-12 12:05:59.000000000 +0530
@@ -82,6 +82,23 @@
 asmlinkage long sys_shmctl (int shmid, int cmd, struct shmid_ds *buf);
 extern void shm_unuse(swp_entry_t entry, struct page *page);
 
+#ifdef CONFIG_SHM
+extern struct ipc_ids shm_ids;
+struct shmid_kernel
+{
+	struct kern_ipc_perm    shm_perm;
+	struct file *           shm_file;
+	int                     id;
+	unsigned long           shm_nattch;
+	unsigned long           shm_segsz;
+	time_t                  shm_atim;
+	time_t                  shm_dtim;
+	time_t                  shm_ctim;
+	pid_t                   shm_cprid;
+	pid_t                   shm_lprid;
+};
+#endif /* CONFIG_SHM */
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SHM_H_ */
diff -urNa openMosix-2.4.21/include/mig_shm/flush.h Migshm-2.4.21/include/mig_shm/flush.h
--- openMosix-2.4.21/include/mig_shm/flush.h	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/include/mig_shm/flush.h	2003-07-12 12:05:59.000000000 +0530
@@ -0,0 +1,8 @@
+#ifndef __LINUX_FLUSH_H
+#define __LINUX_FLUSH_H
+
+#include <linux/linkage.h>
+#include <linux/unistd.h>
+
+_syscall0(long , flush)
+#endif
diff -urNa openMosix-2.4.21/include/mig_shm/load.h Migshm-2.4.21/include/mig_shm/load.h
--- openMosix-2.4.21/include/mig_shm/load.h	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/include/mig_shm/load.h	2003-07-12 12:05:59.000000000 +0530
@@ -0,0 +1,18 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+extern int get_index_loadinfo(int);
+extern void fill_override_array(struct task_struct*, int, int);
+extern int check_load_feasibility(struct task_struct*, int , int);
+extern void determine_links(int);
+extern void take_decision(int, struct task_struct*, int);
+extern void choose_others(struct task_struct*, int);
diff -urNa openMosix-2.4.21/include/mig_shm/log_info.h Migshm-2.4.21/include/mig_shm/log_info.h
--- openMosix-2.4.21/include/mig_shm/log_info.h	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/include/mig_shm/log_info.h	2003-07-12 12:05:59.000000000 +0530
@@ -0,0 +1,64 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+#include <asm-i386/semaphore.h>
+
+/* 
+ * global definitions of all structures required for  
+ * shared memory migrations.
+ */
+struct processinfo 
+{
+	pid_t pid;
+	int home_node;        
+	unsigned long vmstart;
+	unsigned long vmend;
+	unsigned long count; /* The approximate access frequency. 
+			      * Unit: # of accesses/45 secs */
+
+	int  link_flag;      /* link_flag = 0 => weakly linked
+			      * link_flag = 1 => strongly linked */
+	struct processinfo *next_pid;
+};
+
+struct shmeminfo
+{
+	int shmid;
+	int shm_home;       /* where the shared memory was originally created*/
+	int shm_owner;      /* where the latest copy of shared memory is
+			     * maintained */
+
+	long wlcount;       /* Total access count for all weakly linked procs*/
+	long slcount;       /* Total access count for all strong linked procs*/
+	int threshold;
+	struct processinfo *process_link;
+	struct shmeminfo *next_shmid;
+};
+
+#define FLUSH_INTERVAL 50
+
+extern struct shmeminfo *head_info;
+extern struct semaphore shm_sem;
+extern int maask_flag_pgfault;
+extern int maask_flag;
+
+extern struct shmeminfo * get_shmeminfo(pid_t);
+extern void add_shmeminfo(int, int, int);
+extern void add_processinfo(int, unsigned long, pid_t);
+extern void remove_shmeminfo(int, int);
+extern void remove_processinfo(unsigned long);
+extern int get_shm_owner(int, int);
+extern int get_shmid(pid_t);
+extern unsigned long get_shmaddr(pid_t);
+extern void mig_shm_exit();
+extern void log_access(pid_t, unsigned long, int);
+extern void flush_counts();
diff -urNa openMosix-2.4.21/include/mig_shm/shm_comm.h Migshm-2.4.21/include/mig_shm/shm_comm.h
--- openMosix-2.4.21/include/mig_shm/shm_comm.h	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/include/mig_shm/shm_comm.h	2003-07-12 12:05:59.000000000 +0530
@@ -0,0 +1,152 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+#include<linux/types.h>
+
+/* 
+ * This structure is used for sending a page from remote to depiuty just 
+ * after it finishes writeing and releases the lock 
+ */
+struct shm_sync_h
+{
+	unsigned long addr;
+	int shmid;
+	int home;
+	int page_no;
+	char data[PAGE_SIZE];
+	struct file* fp;
+	unsigned long start;
+	unsigned long pgoff;
+	unsigned long end;
+};
+
+/* 
+ * This structure is used to send the parameters to dep_release_lock to be 
+ * executed on the deputy in case of a remote release_lock
+ */
+
+struct rl_lock_h
+{
+	pid_t pid;
+	int shmid;
+	int locktype;
+};
+
+/* 
+ * This structure is used to tranmsfer the shared mnemory information necessary * to insert a shared memory structure in the shmeminfo array and ultimately 
+ * setting up a logical home node for that shared emmory on teh new node 
+ */
+struct mig_shm_h
+{
+	int shmid;
+	unsigned long shmaddr;
+	int inv_nodes[10];
+	int shm_owner;
+};
+/* 
+ * header of messages exchanged through the mig_shm_daemon() 
+ */
+struct mig_shm_msg_h
+{
+	int type;
+	int dlen;
+};
+/* 
+ * structure used for sending invalidate messages 
+ */
+struct invalidate_h
+{
+	int home_node;
+	int shmid, page_no;
+	int writer_node;
+};
+/* 
+ * structure used for broadcasting the change in the owner ndoe when the 
+ * shared memory migrates 
+ */
+struct shm_mig_info_h
+{
+	int shmid;
+	int home_node;
+	int new_owner;
+};
+/* 
+ * structure used for getting a page from the owner node  
+ */
+struct bring_shm_page_h
+{
+	int shmid;
+	int home_node;
+	int pageoff;
+	int page_no;
+};
+/*
+ * structure used to send info during a remote shmat() call
+ */
+struct shm_at_h
+{
+	int shmid;
+	unsigned long shmaddr;
+	int shm_owner;
+	int shm_home;
+};
+/*
+ * structure used to send dirty pages of data section in case of thread 
+ * migration
+ */
+struct thread_sync_h
+{
+	unsigned long addr;
+	pid_t ppid;
+	int node; 
+	int size;
+	unsigned long offset;
+	char data[PAGE_SIZE];
+};
+/*
+ * structure used to indicate to the deputy about a remote shmdt() so that the 
+ * file count gets decremented on home also
+ */
+struct rem_shmdt_h
+{
+	/* Yet to be defined. The processes detaches `cleanly` on the remote
+	 * but the nattach coutn of the shared memory is not decremented yet.
+	 * So this goes in the to-be-done-known-bug-list. 
+	 * Currently normal operation is ensured, but shared memory might be 
+	 * floating if processes detach remotely.
+	 */	
+};
+/*
+ * ports used for communication
+ */
+#define MIG_SHM_DAEMON_PORT    0x3418
+#define SHM_PAGE_WAIT_PORT     0x3419
+
+/*
+ * types used to distinguish between communication messages
+ */
+#define INVALIDATE             0x0001
+#define WRITEBACK              0x0002
+#define SHM_OWNER_BROADCAST    0x0004
+#define SHM_PAGE               0x0008
+#define SYNC_DATA              0x0010
+
+/*
+ * types used for sections of a cloned light-weight process (thread)
+ */
+#define DATA_SECTION           0
+#define THREAD_STACK_SECTION   1
+#define PARENT_STACK_SECTION   2
+
+extern int mig_shm_daemon(void *nothing);
+extern int mig_shm_sendmsg(int type, void* data, int size, int node_num, int unused);
+
diff -urNa openMosix-2.4.21/include/mig_shm/sync.h Migshm-2.4.21/include/mig_shm/sync.h
--- openMosix-2.4.21/include/mig_shm/sync.h	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/include/mig_shm/sync.h	2003-07-12 12:05:59.000000000 +0530
@@ -0,0 +1,21 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+extern int recv_and_sync_page(struct shm_sync_h *, int);
+extern int shm_writeback(int, void*, int);
+extern int writeback_all(void);
+extern int send_invalidate_all(void);
+extern int send_invalidate_msg(struct shm_sync_h *, int);
+extern pte_t * get_pte(struct mm_struct *mm, unsigned long address ) ;
+extern void set_process_migrated(pid_t pid, int node);
+extern int invalidate_pte(struct invalidate_h* im);
+extern void add_page_to_inode_queue(struct address_space *mapping, struct page * page);
diff -urNa openMosix-2.4.21/include/mig_shm/thread.h Migshm-2.4.21/include/mig_shm/thread.h
--- openMosix-2.4.21/include/mig_shm/thread.h	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/include/mig_shm/thread.h	2003-07-12 12:05:59.000000000 +0530
@@ -0,0 +1,19 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+#include <asm-i386/page.h>
+#include<linux/types.h>
+
+extern struct page * follow_page(struct mm_struct *mm, unsigned long address, int write);
+extern void sync_thread_section(struct thread_sync_h** );
+extern int send_thread_section(struct task_struct *p, int type, int peer);
+
diff -urNa openMosix-2.4.21/ipc/sem.c Migshm-2.4.21/ipc/sem.c
--- openMosix-2.4.21/ipc/sem.c	2002-11-29 05:23:15.000000000 +0530
+++ Migshm-2.4.21/ipc/sem.c	2003-07-12 12:05:59.000000000 +0530
@@ -56,6 +56,12 @@
  * Enforced range limit on SEM_UNDO
  * (c) 2001 Red Hat Inc <alan@redhat.com>
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/config.h>
 #include <linux/slab.h>
@@ -64,7 +70,12 @@
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
 #include "util.h"
-
+#ifdef CONFIG_SHM
+#include <hpc/protocol.h>
+#include <mig_shm/sync.h>
+#include <mig_shm/thread.h>
+#include <mig_shm/shm_comm.h>
+#endif /* CONFIG_SHM */
 
 #define sem_lock(id)	((struct sem_array*)ipc_lock(&sem_ids,id))
 #define sem_unlock(id)	ipc_unlock(&sem_ids,id)
@@ -802,7 +813,7 @@
 			return un;
 		}
 	}
-	printk ("freeundos undo list error id=%d\n", un->semid);
+
 	return un->proc_next;
 }
 
@@ -847,6 +858,14 @@
 	int undos = 0, decrease = 0, alter = 0;
 	struct sem_queue queue;
 
+#ifdef CONFIG_SHM
+	unsigned long addr;
+	struct vm_area_struct *vm;
+	struct page *page;
+        int flag1 = 0, flag2 = 0;
+        struct shm_sync_h* shmhdr;
+#endif /* CONFIG_SHM */
+
 	if (nsops < 1 || semid < 0)
 		return -EINVAL;
 	if (nsops > sc_semopm)
@@ -874,7 +893,39 @@
 		if (sop->sem_flg & SEM_UNDO)
 			undos++;
 		if (sop->sem_op < 0)
+		{
 			decrease = 1;
+#ifdef CONFIG_SHM
+		    /* Check for cloned process */
+		    if((current->mosix.mig_flags & MIG_CLONE) && !flag1 ) 
+		    {
+			    flag1 = 1;
+			    if(current->mosix.dflags & DDEPUTY)
+			    {
+				    /* A thread may need to sync it's data 
+				     * section to it's remote siblings 
+				     */ 
+				    deputy_request(DEP_WRITEBACK, NULL, 0, NULL, 0, 0, NULL, 0);
+			    }
+			    else
+			    {
+                                    /* A local writeback has occured */	
+		    		    send_thread_section(current,DATA_SECTION,-1);
+			    }
+		    }
+		    /* Check for shared memory process */
+		    if( (current->mosix.mig_flags & IF_SHMAT) && 
+			(current->mosix.mig_flags & WRITER) && !flag2)
+		    {
+			    flag2 = 1;
+			    if(current->mosix.dflags & DDEPUTY)
+				    deputy_request(DEP_WRITEBACK, NULL, 0, NULL, 0, 0, NULL, 0);
+			    else
+				    writeback_all();
+
+		    }
+#endif /* CONFIG_SHM */
+		}
 		if (sop->sem_op > 0)
 			alter = 1;
 	}
@@ -1032,7 +1083,6 @@
 			if (u == un)
 				goto found;
 		}
-		printk ("sem_exit undo list error id=%d\n", u->semid);
 		goto next_entry;
 found:
 		*unp = un->id_next;
diff -urNa openMosix-2.4.21/ipc/shm.c Migshm-2.4.21/ipc/shm.c
--- openMosix-2.4.21/ipc/shm.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/ipc/shm.c	2003-07-12 12:05:59.000000000 +0530
@@ -15,6 +15,12 @@
  * 
  * Some changes by Moshe Bar to eliminate fh leaking problem in openMosix
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/config.h>
 #include <linux/slab.h>
@@ -26,7 +32,21 @@
 #include <asm/uaccess.h>
 #include <linux/hpc.h>
 #include "util.h"
+#ifdef CONFIG_SHM
+#include <mig_shm/log_info.h>
+#include <linux/printlogs.h>
+#include <hpc/routines.h>
+#include <linux/sched.h>
+#include <mig_shm/sync.h>
+#include <linux/pagemap.h>
+#include <linux/mm.h>
+#include <mig_shm/shm_comm.h>
+#include <hpc/balance.h>
+#include <hpc/protocol.h>
+#include <mig_shm/load.h>
+#endif /*CONFIG_SHM*/
 
+#ifndef CONFIG_SHM
 struct shmid_kernel /* private to the kernel */
 {
 	struct kern_ipc_perm	shm_perm;
@@ -40,13 +60,15 @@
 	pid_t			shm_cprid;
 	pid_t			shm_lprid;
 };
-
+#endif /* CONFIG_SHM */
 #define shm_flags	shm_perm.mode
 
 static struct file_operations shm_file_operations;
 static struct vm_operations_struct shm_vm_ops;
-
-static struct ipc_ids shm_ids;
+#ifndef CONFIG_SHM
+static 
+#endif /* CONFIG_SHM */
+struct ipc_ids shm_ids;
 
 #define shm_lock(id)	((struct shmid_kernel*)ipc_lock(&shm_ids,id))
 #define shm_unlock(id)	ipc_unlock(&shm_ids,id)
@@ -94,13 +116,17 @@
 	return ipc_addid(&shm_ids, &shp->shm_perm, shm_ctlmni+1);
 }
 
-
-
-static inline void shm_inc (int id) {
+static inline void shm_inc (int id) 
+{
 	struct shmid_kernel *shp;
 
 	if(!(shp = shm_lock(id)))
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d-shm_inc:BUG- shmid removed on home\n",current->pid);
+#endif /* CONFIG_SHM_DEBUG */
 		BUG();
+	}
 	shp->shm_atim = CURRENT_TIME;
 	shp->shm_lprid = current->pid;
 	shp->shm_nattch++;
@@ -150,8 +176,11 @@
 	shp->shm_lprid = current->pid;
 	shp->shm_dtim = CURRENT_TIME;
 	shp->shm_nattch--;
-	if(shp->shm_nattch == 0 &&
-	   shp->shm_flags & SHM_DEST)
+	if(shp->shm_nattch == 0 && shp->shm_flags & SHM_DEST
+#ifdef CONFIG_SHM
+	   && !(current->mosix.dflags & DPASSING)
+#endif /* CONDIF_SHM */
+)
 		shm_destroy (shp);
 	else
 		shm_unlock(id);
@@ -255,6 +284,11 @@
 		shm_unlock(id);
 	}
 	up(&shm_ids.sem);
+#ifdef CONFIG_SHM
+        if( err >= 0 )
+		add_shmeminfo( err, PE, PE );
+#endif/*CONFIG_SHM*/
+
 	return err;
 }
 
@@ -519,7 +553,13 @@
 			shp->shm_perm.key = IPC_PRIVATE;
 			shm_unlock(shmid);
 		} else
+		{
+#ifdef CONFIG_SHM
+		  remove_shmeminfo(shmid, PE); /* happens always
+						* on DEPUTY */
+#endif /*CONFIG_SHM*/
 			shm_destroy (shp);
+		}
 		up(&shm_ids.sem);
 		return err;
 	}
@@ -582,9 +622,19 @@
 	int acc_mode;
 	void *user_addr;
 
+#ifdef CONFIG_SHM
+	if(current->mosix.nshm == 0)
+		current->mosix.mig_flags |= IF_SHMAT; 
+	else
+		current->mosix.mig_flags &= ~IF_SHMAT;
+	current->mosix.nshm++;
+	if(shmflg & SHM_RDONLY)
+		current->mosix.mig_flags &= ~WRITER;
+	else
+		current->mosix.mig_flags |= WRITER;
+#endif/*CONFIG_SHM*/
 	if (shmid < 0)
 		return -EINVAL;
-
 	if ((addr = (ulong)shmaddr)) {
 		if (addr & (SHMLBA-1)) {
 			if (shmflg & SHM_RND)
@@ -669,6 +719,36 @@
 	err = 0;
 	if (IS_ERR(user_addr))
 		err = PTR_ERR(user_addr);
+#ifdef CONFIG_SHM
+
+        if(!err && !(current->mosix.dflags & DDEPUTY) && !(current->mosix.dflags & DREMOTE))
+		add_processinfo(shp->id, *raddr, current->pid);
+        else if(!err)
+	{
+		struct shm_at_h data;
+		struct shmeminfo* travshm = head_info;
+
+		if(!(shp = shm_lock(shmid)))
+			BUG();
+		while(travshm)
+		{
+			if(travshm->shmid == shp->id)
+			{
+				data.shmid = shp->id;
+				data.shmaddr = (*raddr);
+				data.shm_owner = travshm->shm_owner;
+				data.shm_home = travshm->shm_home;
+				deputy_request(REM_SHMAT, &data, sizeof(data), NULL, 0, 0, NULL, 0);
+				break;
+			}
+			travshm = travshm->next_shmid;
+		}
+		shm_unlock(shmid);
+	}
+        else
+		current->mosix.mig_flags &= ~IF_SHMAT;
+#endif /*CONFIG_SHM*/
+
 	return err;
 
 }
@@ -689,6 +769,21 @@
 	mosix_rebuild_file_list();
 #endif /* CONFIG_MOSIX */
 	down_write(&mm->mmap_sem);
+#ifdef CONFIG_SHM
+        if( (shmd = find_vma(current->mm,(unsigned long)shmaddr)) == NULL )
+		printk("Vma not found\n");
+        else
+	{
+		do_munmap(mm, shmd->vm_start, shmd->vm_end - shmd->vm_start, 1);
+		remove_processinfo((unsigned long)shmaddr);
+		current->mosix.nshm = current->mosix.nshm - 1;
+		if(current->mosix.nshm > 1)
+			current->mosix.mig_flags &= ~IF_SHMAT;
+		else
+			current->mosix.mig_flags |= IF_SHMAT;
+		retval = 0;
+	}
+#else
 	for (shmd = mm->mmap; shmd; shmd = shmdnext) {
 		shmdnext = shmd->vm_next;
 		if (shmd->vm_ops == &shm_vm_ops
@@ -697,6 +792,7 @@
 			retval = 0;
 		}
 	}
+#endif /* CONFIG_SHM */
 	up_write(&mm->mmap_sem);
 	return retval;
 }
diff -urNa openMosix-2.4.21/ipc/util.c Migshm-2.4.21/ipc/util.c
--- openMosix-2.4.21/ipc/util.c	2002-11-29 05:23:15.000000000 +0530
+++ Migshm-2.4.21/ipc/util.c	2003-07-12 12:05:59.000000000 +0530
@@ -9,6 +9,12 @@
  * Nov 1999 - ipc helper functions, unified SMP locking
  *	      Manfred Spraul <manfreds@colorfullife.com>
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/config.h>
 #include <linux/mm.h>
@@ -19,6 +25,9 @@
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
 #include <linux/highuid.h>
+#ifdef CONFIG_SHM
+#include <mig_shm/log_info.h>
+#endif /*CONFIG_SHM*/
 
 #if defined(CONFIG_SYSVIPC)
 
diff -urNa openMosix-2.4.21/kernel/exit.c Migshm-2.4.21/kernel/exit.c
--- openMosix-2.4.21/kernel/exit.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/kernel/exit.c	2003-07-12 12:06:00.000000000 +0530
@@ -18,6 +18,9 @@
 #endif
 #ifdef CONFIG_MOSIX
 #include <linux/hpc.h>
+#ifdef CONFIG_SHM
+#include <mig_shm/log_info.h>
+#endif /* CONFIG_SHM */
 #endif /* CONFIG_MOSIX */
 
 #include <asm/uaccess.h>
@@ -522,11 +525,16 @@
 
 fake_volatile:
 #ifdef CONFIG_MOSIX
+#ifdef CONFIG_SHM
+        mig_shm_exit();
+#endif /* CONFIG_SHM */
+
 	mosix_exit();
 #endif /* CONFIG_MOSIX */
 #ifdef CONFIG_BSD_PROCESS_ACCT
 	acct_process(code);
 #endif
+	
 	__exit_mm(tsk);
 
 	lock_kernel();
diff -urNa openMosix-2.4.21/kernel/fork.c Migshm-2.4.21/kernel/fork.c
--- openMosix-2.4.21/kernel/fork.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/kernel/fork.c	2003-07-12 12:08:41.000000000 +0530
@@ -11,8 +11,12 @@
  * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'
  */
 /* some openMosix fork changes introduce by Moshe Bar */
-
-
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/config.h>
 #include <linux/slab.h>
@@ -34,6 +38,11 @@
 
 #ifdef CONFIG_MOSIX
 #include <linux/hpc.h>
+#ifdef CONFIG_SHM
+#include <mig_shm/log_info.h>
+#include <asm/atomic.h>
+#endif /*CONFIG_SHM*/
+
 #endif /* CONFIG_MOSIX */
 
 /* The idle threads do not count.. */
@@ -738,6 +747,14 @@
 	struct completion vfork;
 #ifdef CONFIG_MOSIX
 	int migrated = 0;
+#ifdef CONFIG_SHM
+	int shmid = -1;
+ 	unsigned long vmstart = 0;
+ 	struct mm_struct* mm;
+ 	struct vm_area_struct* vma;
+ 	struct ptregs* temp;
+#endif /* CONFIG_SHM */
+
 #endif /* CONFIG_MOSIX */
 
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
@@ -956,6 +973,57 @@
 #endif /* CONFIG_MOSIX */
 
 fork_out:
+#ifdef CONFIG_SHM
+	/* current->pid and retval are the 2 processes */
+
+	p->mosix.mig_flags = 0;
+
+	if( current->mosix.mig_flags & IF_SHMAT )
+	{
+		p->mosix.mig_flags |= IF_SHMAT;
+
+		shmid = get_shmid(current->pid); 
+		if( shmid != -1 ) /* shared mem process */
+		{
+			/* 
+			 * Insert in structure new process and get the virtual
+			 * address from get_shmeminfo.
+			 */    
+		
+			vmstart = get_shmaddr( current->pid ); 
+			add_processinfo(shmid, vmstart, p->pid);
+		}
+	}
+	if(p->mosix.stay & DSTAY_FOR_CLONE)
+	{
+		task_lock(p);
+		mm = current->mm;
+		/* Remember the stack_start and the parent pid of the new 
+		 * thread. 
+		 */
+		if( mm && (atomic_read(&mm->mm_realusers) > 1) && !(clone_flags & CLONE_VFORK) )
+		{
+			p->mosix.ppid = current->pid;
+			current->mosix.ppid = 0;
+			p->mosix.start_stack = stack_start;
+
+			if(clone_flags & SIGRTMIN)
+			{
+				p->mosix.mig_flags &= ~MIG_CLONE;
+				p->mosix.stay |= DSTAY_FOR_CLONE;
+			}
+			else
+			{
+				p->mosix.mig_flags |= MIG_CLONE;
+				p->mosix.stay &= ~DSTAY_FOR_CLONE;
+			}
+
+			current->mosix.mig_flags &= ~MIG_CLONE;
+			current->mosix.stay |= DSTAY_FOR_CLONE;
+		}
+		task_unlock(p);	
+	}
+#endif /*CONFIG_SHM*/
 	return retval;
 
 bad_fork_cleanup_namespace:
diff -urNa openMosix-2.4.21/Makefile Migshm-2.4.21/Makefile
--- openMosix-2.4.21/Makefile	2003-07-12 11:14:02.000000000 +0530
+++ Migshm-2.4.21/Makefile	2003-07-12 12:06:00.000000000 +0530
@@ -130,6 +130,12 @@
 ifdef CONFIG_MOSIX
 CORE_FILES	+= $(TOPDIR)/hpc/hpc.o
 SUBDIRS		=hpc kernel drivers mm fs net ipc lib
+
+ifdef CONFIG_SHM
+CORE_FILES      += $(TOPDIR)/mig_shm/mig_shm.o
+SUBDIRS         +=mig_shm 
+endif
+
 else
 SUBDIRS		=kernel drivers mm fs net ipc lib
 endif
diff -urNa openMosix-2.4.21/mig_shm/load.c Migshm-2.4.21/mig_shm/load.c
--- openMosix-2.4.21/mig_shm/load.c	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/mig_shm/load.c	2003-07-12 12:06:00.000000000 +0530
@@ -0,0 +1,254 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+/*
+ * linux/mig_shm/load.c
+ * This file contains the functions needed for 
+ *   1) Shared memory migration
+ *   2) Group process migration
+ */
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/hpcctl.h>
+#include <hpc/routines.h>
+#include <hpc/protocol.h>
+#include <linux/hpc.h>
+#include <asm/uaccess.h>
+#include <asm/i387.h>
+#include <linux/smp_lock.h>
+#include <linux/stddef.h>
+#include <hpc/comm.h>
+#include <hpc/debug.h>
+#include <hpc/hpcversion.h>
+#include <hpc/balance.h>
+#include <mig_shm/log_info.h>
+#include <mig_shm/shm_comm.h>
+
+#define THRESHOLD 20
+/*
+ * get_index_loadinfo returns the index of the passed node in the loadinfo 
+ * array
+ */
+int get_index_loadinfo( int node )
+{
+	int i;
+	for( i = 0 ; i < INFO_WIN; i++ )
+	{
+		if ( loadinfo[i].pe == node )
+			return i;
+	}
+	return 0;
+}
+/*
+ * fill_override_array - All the strongly linked process are added to the overr * ide array. This is done to indicate which processes are to be migrated durin * g group process migration.
+ */
+void fill_override_array(struct task_struct *sel, int k, int override_arr[10])
+{
+	struct shmeminfo *travshm = head_info;
+	struct processinfo * travproc = NULL;
+	struct task_struct *p =NULL;
+	int i=0;
+	travshm = get_shmeminfo(sel->pid);
+
+	travshm->shm_owner = k;
+	travproc = travshm->process_link;
+
+	while(travproc)
+	{
+		if( travproc->link_flag == 1 ) 
+		{
+			p = find_any_task_by_pid(travproc->pid);
+			if(p->pid != sel->pid)
+				override_arr[i++] = travproc->pid;
+
+		}
+		travproc = travproc->next_pid;
+	}
+}
+void sort(int count[500], int n)
+{
+	int i, j, temp;
+
+	for(i = 0; i < n; i++)
+		for(j = i+1; j < n; j++)
+			if(count[i] > count[j])
+			{
+				temp = count[i];
+				count[i] = count[j];
+				count[j] = temp;
+			}
+}
+int lower_avg(int count[500], int partition, int n)
+{
+	int i, sum = 0, nlower = 1;
+
+	for(i = 0; i < n; i ++)
+		if(count[i] < partition)
+		{
+			sum += count[i];
+			nlower++;
+		}
+	return(sum/nlower);
+
+}
+
+int higher_avg(int count[500], int partition, int n)
+{
+	int i, sum = 0, nhigher = 1;
+
+	for(i = 0; i < n; i ++)
+		if(count[i] >= partition)
+		{
+			sum += count[i];
+			nhigher++;
+		}
+	return(sum/nhigher);
+
+}
+/*
+ * determine_links - determine whether the shared memory processes are weakly 
+ * linked or strongly linked to the shared memory. The process is strongly 
+ * linked implies that the proces access the shared memory above a threshold
+ * (an application specific absolute value)
+ */
+void determine_links(int shmid)
+{
+	/* The thresold chosen is ideal for Apache web server */
+	//int count[500], n = 0, partition = 0;
+	struct shmeminfo *travshm = head_info;
+	struct processinfo *travproc = NULL;
+
+	/*	while(travshm != NULL)
+	{
+		if(travshm->shmid == shmid)
+		{	
+			travproc = travshm->process_link;
+			while(travproc != NULL)
+			{ */       /* copy all counts */
+	/*	count[n++] = travproc->count;
+				travproc = travproc->next_pid;
+			}
+			break;
+		}
+		travshm = travshm->next_shmid;
+	}
+	*/
+	/* Calculate the 'threshold' dynamically, per application basis */
+	/*	sort(count, n);
+	partition = ( count[n-1] - count[0] ) / 2;
+	travshm->threshold = (lower_avg(count, partition, n) + higher_avg(count, partition, n)) / 2; */
+//	printk("%d-partition is.... %d\n", current->pid, partition);
+//	printk("%d-threshold is.... %d\n", current->pid, travshm->threshold);
+
+	while(travshm != NULL)
+	{
+		if(travshm->shmid == shmid)
+		{	
+		  	travproc = travshm->process_link;
+			travshm->slcount = 0;
+			travshm->wlcount = 0;
+			while(travproc != NULL)
+			{
+				/* weakly linked process */
+				//if(travproc->count <= travshm->threshold) 
+				if(travproc->count < THRESHOLD) 
+				{
+					travshm->wlcount =  travshm->wlcount + travproc->count;
+					travproc->link_flag = 0;
+				}
+				/* strongly linked process */
+				else                     
+				{
+					travshm->slcount = travshm->slcount + travproc->count;
+					travproc->link_flag = 1;
+				}
+				travproc = travproc->next_pid;
+			}
+			break;
+		}
+		travshm = travshm->next_shmid;
+	}
+}
+
+/* 
+ * This function makes the override flag 0 or 1 depending on whether the 
+ * selected process is weakly linked to the shared memory or strongly linked 
+ * to the shared memory. If the override flag is set, the shared memory is to 
+ * be migrated *with the selected process. 
+ */
+void take_decision(int shmid, struct task_struct *sel, int reason)
+{
+	int link_flag = 0, found = 0;
+	struct shmeminfo *travshm = head_info;
+	struct processinfo *travproc;
+
+	/* find the selected process in the shared memory data structure */
+	while(travshm != NULL)
+	{
+		if(travshm->shmid == shmid && travshm->shm_home == PE)
+		{
+			travproc = travshm->process_link;
+			while(travproc != NULL)
+			{
+				if(sel->pid == travproc->pid)
+				{
+					link_flag = travproc->link_flag;
+					found = 1;
+					break;
+				}
+				travproc = travproc->next_pid;
+			}
+		}
+		if(found)
+			break;
+		travshm = travshm->next_shmid;
+	}
+	/* decision making cases:
+	 * reason = -2 , the process is chosen for load balance by openMosix
+	 */
+	if(reason == -2) 
+	{
+		/* link_flag = 0, the process is weakly linked to the shared 
+		 * memory */
+		if(!link_flag)     
+			sel->mosix.mig_flags &= ~OVERRIDE;
+		/* link_flag = 1, the process is strongly linked to the 
+		 * shared memory */
+		else if(link_flag == 1) 
+		{
+			if(travshm->shm_owner == PE)
+			{
+				if( (travshm->slcount + travshm->wlcount - travproc->count) < (travproc->count) )
+				{
+				/* setting override flag indicates that 
+				 * shared memory should migrate */
+					sel->mosix.mig_flags |= OVERRIDE;  
+				}
+			}
+		}
+	}
+} 
+/* choose_others- This function enhances the migration decisions of openMosix 
+ * depending on the shared memory usage 
+ */
+void choose_others(struct task_struct *sel, int reason)
+{
+	int shmid;
+	shmid = get_shmid(sel->pid);
+	/* shmid >= 0 => the process is a shared memory process */
+	if(shmid >= 0) 
+	{
+		determine_links(shmid);
+		take_decision(shmid, sel, reason);
+	}
+}
+
diff -urNa openMosix-2.4.21/mig_shm/log_info.c Migshm-2.4.21/mig_shm/log_info.c
--- openMosix-2.4.21/mig_shm/log_info.c	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/mig_shm/log_info.c	2003-07-12 12:06:00.000000000 +0530
@@ -0,0 +1,479 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+/* 
+ * log_info.c - This file has all functions neede to manipulate the shmeminfo 
+ * and processiunfo structures used to maintain shared memory and process info
+ * for all processes associated with shared memory regions
+ */
+
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/smp_lock.h>
+#include <mig_shm/shm_comm.h>
+#include <mig_shm/log_info.h>
+#include <mig_shm/flush.h>
+#include <asm/atomic.h>
+
+struct shmeminfo *head_info = NULL; /* Head of the list of shmeminfo's */
+int maask_flag = 0;                 
+
+/* add_shmeminfo- This function adds the shared memory info into a list headed
+ * by head_info. This happens in 3 cases: 
+ * #1 This process does an shmget()
+ * #2 This is a shared memory process migrated to this node and is the first 
+ * in its `group`
+ * #3 This process was forked by a shared memory process 
+ */
+void add_shmeminfo ( int shmid , int shm_owner, int home )
+{
+	int flag = 0;
+  	struct shmeminfo *iso = NULL, *travshm;
+
+	lock_kernel();
+	
+	travshm = head_info;
+
+        iso = ( struct shmeminfo *)kmalloc( sizeof(struct shmeminfo ), GFP_KERNEL);
+        iso->shmid = shmid;
+	iso->shm_owner = shm_owner;
+	iso->shm_home = home;
+        iso->process_link = NULL;
+        iso->next_shmid = NULL;
+
+	if(!head_info)						      
+		head_info = iso;
+	else 
+	{		
+		while(travshm)
+		{
+			/* Check if shmeminfo already exists */ 
+			if((travshm->shmid == shmid) && (travshm->shm_home == home))
+			{
+				flag = 1;
+				break;
+			}
+			if(travshm->next_shmid == NULL)
+				break;
+			travshm = travshm->next_shmid;
+		}
+		/* shmeminfo for shmid not found. Add it to the end. */
+		if(!flag)	
+			travshm->next_shmid = iso;
+	}
+	unlock_kernel();
+}
+/* add_processinfo- This function adds information of this process entry to
+ * the lists of processes attached to shmid.
+ */
+void add_processinfo( int shmid, unsigned long address, pid_t my_pid)
+{
+	struct shmeminfo *travshm;
+	struct task_struct *p = NULL;
+	struct processinfo *iso = NULL, *trav = NULL;
+	struct vm_area_struct *vma;
+	int shm_home;
+
+
+	lock_kernel();
+	travshm = head_info;
+
+	if((iso = (struct processinfo *)kmalloc( sizeof( struct processinfo), GFP_KERNEL)) == NULL)
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d-add_processinfo: Could not allocate memory\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		return(-1);
+	}
+	iso->pid = my_pid;
+	iso->next_pid = NULL; 
+	iso->count = 0;
+
+	p = find_any_task_by_pid(my_pid);
+	vma = find_vma(p->mm, address);
+	
+	iso->vmstart = vma->vm_start;
+	iso->vmend = vma->vm_end;
+  
+	if(p->mosix.dflags & DREMOTE)
+		shm_home = p->mosix.deppe;
+	else
+		shm_home = PE;
+
+	if(!travshm->next_shmid)
+	{		
+		if( (travshm->shmid == shmid) && (travshm->shm_home == shm_home ) )
+		{
+			if(!travshm->process_link)
+				travshm->process_link = iso;
+			else						
+			{
+				trav = travshm->process_link;
+				while(trav->next_pid != NULL)	
+					trav = trav->next_pid;
+				trav->next_pid = iso ;
+			}
+		}
+	}
+	else
+	{
+		while(travshm)
+		{    
+			if((travshm->shmid == shmid) && (travshm->shm_home == shm_home) )
+			{
+				trav = travshm->process_link;
+				if(travshm->process_link == NULL)
+					travshm->process_link = iso;
+				else
+				{
+					while(trav->next_pid != NULL)	
+						trav = trav->next_pid;
+					trav->next_pid = iso;
+				}
+			}
+			travshm = travshm->next_shmid;
+		}
+	}
+	unlock_kernel();
+}
+
+/* remove_shmeminfo- Destroy the shmeminfo structure when the shared memory
+ * region is destroyed in shmctl()
+ */
+void remove_shmeminfo(int shmid, int home)
+{
+	struct shmeminfo  *travshm = head_info, *btravshm = head_info;
+  
+	lock_kernel();
+	while(travshm)
+	{
+		if ((travshm->shmid == shmid) && (travshm->shm_home == home))
+		{
+			/* we have to delete this node */
+			if(travshm == head_info) /* first node in our list */
+				head_info = travshm->next_shmid;
+			else 
+				btravshm->next_shmid = travshm->next_shmid;
+			kfree(travshm);
+			unlock_kernel();		
+			return;
+		}
+		btravshm = travshm;
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+#ifdef CONFIG_SHM_DEBUG
+	printk("%d-remove_shmeminfo: %d, %d shmeminfo not found\n", current->pid, shmid, home);
+#endif /* CONFIG_SHM_DEBUG */
+	return;
+}
+/* remove_processinfo- Destroy information about the shared memory process
+ * either when it detaches from the memory region ( shmdt() ), or when it
+ * migrates to another node.
+ */
+void remove_processinfo( unsigned long shmaddr )
+{
+	struct shmeminfo * travshm = head_info;
+	struct processinfo *travproc, *btravproc;
+	struct task_struct* p = current;	
+	int found = 0;
+
+	lock_kernel();
+	while( travshm )
+	{
+		btravproc = NULL;
+		travproc = travshm->process_link;
+		while (travproc)
+		{
+			if (travproc->pid == p->pid && travproc->vmstart == shmaddr)
+			{
+				if(btravproc)
+					btravproc->next_pid = travproc->next_pid;
+				else
+					travshm->process_link = travproc->next_pid;
+				kfree(travproc);
+				found = 1;
+				break;
+			}
+			btravproc = travproc; 
+			travproc = travproc->next_pid;
+		}
+		if (found)
+			break;
+		travshm =travshm->next_shmid;
+	} 
+	unlock_kernel();
+#ifdef CONFIG_SHM_DEBUG
+	if( !found )
+		printk("%d-remove_processinfo: processinfo not found\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+}
+
+/* get_shmeminfo- This is used to retrieve the shmared memory info structure 
+ * from the list.
+ */
+struct shmeminfo* get_shmeminfo( pid_t pid )
+{
+	struct shmeminfo * travshm;
+	struct processinfo * travproc;
+	
+	lock_kernel();
+	travshm = head_info;
+	while( travshm )
+	{
+		travproc = travshm->process_link;
+		while( travproc )
+		{
+			if(travproc->pid == pid)
+			{
+				/* My shmid found */
+				unlock_kernel();
+				return travshm;
+			}
+			travproc = travproc->next_pid;
+		}
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+	return NULL;
+}
+
+int get_shm_owner(int shmid, int home)
+{ 
+	struct shmeminfo* travshm;
+
+	lock_kernel();
+	travshm = head_info;
+	while(travshm)
+	{
+		if((travshm->shmid == shmid) && (travshm->shm_home == home))
+		{
+			unlock_kernel();
+			return(travshm->shm_owner);
+		}	
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+#ifdef CONFIG_SHM_DEBUG
+	printk("%d-get_shm_owner: shmeminfo not found\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+	return(-1);
+}
+
+int get_shmid(pid_t pid)
+{
+	struct shmeminfo* travshm;
+	struct processinfo* travproc;
+
+	lock_kernel();
+	travshm = head_info;
+	while(travshm)
+	{
+		travproc = travshm->process_link;
+		while(travproc)
+		{
+			if(travproc->pid == pid)
+			{
+				unlock_kernel();
+				return(travshm->shmid);
+			}
+			travproc = travproc->next_pid;
+		}
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+
+	//#ifdef CONFIG_SHM_DEBUG
+	//	printk("%d-get_shmid: shmeminfo not found\n", current->pid);
+	//#endif /* CONFIG_SHM_DEBUG */
+	return -1;
+}
+
+unsigned long get_shmaddr(pid_t pid)
+{
+	struct shmeminfo* travshm;
+	struct processinfo* travproc;
+
+	lock_kernel();
+	travshm = head_info;
+	while(travshm)
+	{
+		travproc = travshm->process_link;
+		while(travproc)
+		{
+			if(travproc->pid == pid)
+			{
+				unlock_kernel();
+				return(travproc->vmstart);
+			}
+			travproc = travproc->next_pid;
+		}
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+#ifdef CONFIG_SHM_DEBUG
+	printk("%d-get_shmaddr: shmeminfo not found\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+	return(-1);
+}
+
+int update_shm_mig(struct shm_mig_info_h* sm)
+{
+	struct shmeminfo * travshm;
+
+
+	lock_kernel();
+	travshm = head_info;
+	while(travshm != NULL)
+	{
+	
+
+		if(travshm->shmid == sm->shmid && travshm->shm_home == sm->home_node)
+		{
+		
+			travshm->shm_owner = sm->new_owner ;
+			unlock_kernel();
+			return 0;
+		}	 
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+	return -1;
+}
+/* mig_shm_exit- This functions cleans up the entry of this process in the
+ * shared memory info list when the process exits. This is useful if the 
+ * process does and shmat() but not an shmdt(). 
+ */
+void mig_shm_exit()
+{
+
+	if((current->mosix.mig_flags & MIG_CLONE) || (current->mosix.mig_flags & IF_SHMAT))
+		sys_flush();       /* if process exits on remote... 
+				    * flush out dirty pages if any. */
+	if((current->mosix.mig_flags & IF_SHMAT) && (get_shmid(current->pid) != -1))
+		remove_processinfo(get_shmaddr(current->pid));	
+	
+	/* If process attaches but doesnt not explicitly detach from the
+	 * shared memory, remove its entry on exit 
+	 */
+}
+/* log_access_patterns- This function increments counts for read/write accesses
+ * of process pid. It is invoked from the mosix_mem_daemon when pages of this
+ * process are detected as `accessed` by the memsorter. 
+ */
+void log_access(pid_t pid, unsigned long vm_start, int type)
+{
+	struct shmeminfo *travshm = NULL;
+	struct processinfo *travproc = NULL;
+	struct task_struct* q = NULL;
+
+	q = find_any_task_by_pid(pid);
+	/* Check if this function was called only by us */
+
+	lock_kernel();
+
+	if(q && maask_flag) 
+	{
+		travshm = get_shmeminfo(pid);
+	
+		if(travshm)
+		  {
+			  travproc = travshm->process_link;
+			  while(travproc)
+			  {
+				  /* Increment counts only for pages in the 
+				   * shared memory region. 
+				   */
+				  if(travproc->pid == pid && travproc->vmstart == vm_start)
+				  {
+				/* Remote write accesses involve a heavier 
+				 * overhead than read accesses.  
+				 */
+					  
+				/* read access */
+					  if(type == 0 && travproc) 
+						  travproc->count++;
+			        /* write access */
+					  else if(type == 1 && travproc)      
+						  travproc->count = travproc->count + 3;
+					  // printk(".");
+					  unlock_kernel();
+					  return;
+				  }
+				  travproc = travproc->next_pid;
+			  }
+		  }
+	}
+	unlock_kernel();
+}
+
+/* flush_counts- This function flushes the logged access counts, for all shared
+ * memory regions, of each process attached to it after every FLUSH_INTERVAL 
+ * # of invocations of the mosix_mem_daemon, which turns out to be 
+ * approximately 45 secs when the FLUSH_INTERVAL is 50. 
+ * Thus the counts signify the number of accesses to the shared memory every 
+ * 45 secs.
+ */
+void flush_counts()
+{
+	struct shmeminfo* travshm;
+	struct processinfo* travproc;
+
+	lock_kernel();
+	travshm = head_info;
+	while(travshm) /* for each shared memory region */
+	{
+		travproc = travshm->process_link;
+		while(travproc) /* for each process attached ot it */
+		{
+			/* zero the count */
+			
+			travproc->count = 0;
+			travproc = travproc->next_pid;
+		}
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+}
+
+asmlinkage long sys_printlogs(void)
+{
+	struct shmeminfo *travshm = head_info;
+	struct processinfo *travproc;
+	int n = 0, p;
+
+	printk("\nPrinting the shared memory information structure...\n");
+		
+	while(travshm)
+	{
+		printk("---------------------------------------------------\n");
+		printk("The contents of shmeminfo-%d:\n ", n);
+		printk("shmid = %d - ",travshm->shmid, travshm->process_link, travshm->next_shmid );
+		printk("shm_home : %d     ", travshm->shm_home);
+ 		printk("shm_owner: %d\n", travshm->shm_owner);
+	
+		p = 0;
+		travproc =  travshm->process_link;
+
+		while(travproc)
+		{
+			printk("        Process %d:     ", p++);
+			printk("pid: %d      ",travproc->pid, travproc->vmstart, travproc->vmend);
+			printk("count: %d\n", travproc->count);	 	
+			travproc = travproc->next_pid;
+		}
+		n++;   
+		travshm = travshm->next_shmid;
+	}
+	return 0;
+}
diff -urNa openMosix-2.4.21/mig_shm/Makefile Migshm-2.4.21/mig_shm/Makefile
--- openMosix-2.4.21/mig_shm/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/mig_shm/Makefile	2003-07-12 12:06:00.000000000 +0530
@@ -0,0 +1,8 @@
+#
+# Makefile for the mosix shared memory migration.
+#
+O_TARGET := mig_shm.o
+
+obj-$(CONFIG_SHM) += thread.o shm_comm.o log_info.o sync.o load.o
+
+include $(TOPDIR)/Rules.make
diff -urNa openMosix-2.4.21/mig_shm/shm_comm.c Migshm-2.4.21/mig_shm/shm_comm.c
--- openMosix-2.4.21/mig_shm/shm_comm.c	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/mig_shm/shm_comm.c	2003-07-12 12:06:00.000000000 +0530
@@ -0,0 +1,528 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+/* 
+ * shm_comm.c- This file has all communication between remote shared memory 
+ * processes. The processes cannot use openMosix communication at all since 
+ * openMosix handles communication between the remotely executing process and
+ * its deputy stub, and not between a remotely executing process and another
+ * process executing on the deputy or any ther node.
+ */
+
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <linux/in.h>
+#include <linux/net.h>
+#include <net/sock.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <hpc/routines.h>
+#include <mig_shm/sync.h>
+#include <asm/fixmap.h>
+#include <mig_shm/log_info.h>
+#include <mig_shm/shm_comm.h>
+#include <linux/pagemap.h>
+#include "../ipc/util.h"
+#include <linux/shm.h>
+
+#define shm_lock(id)    ((struct shmid_kernel*)ipc_lock(&shm_ids,id))
+
+int mig_shm_daemon_active = 0;
+/*
+ * mig_shm_sendmsg - This is a genric function which sends a packet to the 
+ * mig_shm_daemon on any ndoe.
+ */
+int mig_shm_sendmsg(int type, void* data, int size, int node_num, int bcast)
+{
+	int error = 0, hlen = sizeof(struct mig_shm_msg_h), msg_size = 0;
+	struct mig_shm_msg_h mig_shm_head;
+	struct socket *sock_send;
+	struct sockaddr_in ra;
+	struct iovec iov[2];
+	struct msghdr msg;
+	mm_segment_t oldfs;
+	
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	if(data)
+	{
+		msg.msg_iovlen = 2;
+		msg.msg_iov = iov;
+	}
+	else
+	{
+		msg.msg_iovlen = 1; /* sending a NULL message */
+		msg.msg_iov = iov;
+	}
+	msg.msg_name = &ra;
+	msg.msg_flags = 0;
+	msg.msg_namelen = sizeof(struct sockaddr_in);
+	
+	if( (error = sock_create(PF_INET, SOCK_DGRAM, IPPROTO_UDP, &sock_send)) < 0)
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d-mig_shm_sendmsg: Error in sock_create",current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		return error;
+	}
+		
+	if(bcast)
+		sock_send->sk->broadcast = 1;
+	
+	if( (!bcast) && (error = mos_to_net(node_num, (void *)&ra)) < 0 )
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d-mig_shm_sendmsg: Error in mos_to_net to node %d",current->pid, node_num);
+#endif /* CONFIG_SHM_DEBUG */
+		sock_release(sock_send);
+		return error;
+	}
+	
+	ra.sin_family = AF_INET;
+	if(bcast)                         /* broadcast address */
+		ra.sin_addr.s_addr = htonl( (__u32) 0xffffffff);
+	ra.sin_port = MIG_SHM_DAEMON_PORT;
+	
+	mig_shm_head.type = type;
+	mig_shm_head.dlen = size;
+	
+	iov[0].iov_base = &mig_shm_head;  /* header */
+	iov[0].iov_len = hlen; 
+
+	if(data)
+	{
+		iov[1].iov_base = data;  /* data */
+		iov[1].iov_len = size; 
+	}
+	
+	msg_size = hlen + size;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	error = sock_sendmsg( sock_send, &msg, msg_size );
+	set_fs(oldfs);
+	
+	sock_release(sock_send);
+	return (error);
+}
+/*
+ * send_page_request - A remote page fault has occurred. This function fetches
+ * the page from the owner of the shared memory.  
+ */
+int send_page_request(int owner, struct bring_shm_page_h bshm, struct page* page)
+{
+	struct socket *sock;
+	struct sockaddr_in ra1, ra2, sa;
+	struct iovec iov[2];
+	struct msghdr msg;
+	struct mig_shm_msg_h mig_shm_head;
+	mm_segment_t oldfs;
+	char *buffer;
+	int error, size, hlen, msg_size;
+
+	if( (error = mos_to_net(PE, (void *)&sa)) < 0 )
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d-send_page_request: Error in mos_to_net to node %d",current->pid, PE);
+#endif /* CONFIG_SHM_DEBUG */
+		return error;
+	}
+
+	/* sender address */
+
+	sa.sin_family = PF_INET;
+	sa.sin_port = SHM_PAGE_WAIT_PORT;
+
+	if( (error = sock_create(PF_INET, SOCK_DGRAM, IPPROTO_UDP, &sock)) < 0 )
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("Error in sock create : %d\n",error);
+		return error;
+#endif /* CONFIG_SHM_DEBUG */
+	}
+	
+	if( (error = sock->ops->bind(sock, (struct sockaddr *)&sa, sizeof(struct sockaddr_in))) < 0 )
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("error in bind.. errr : %d", error);
+		sock_release(sock);
+		return error;
+#endif /* CONFIG_SHM_DEBUG */
+	}	
+	/* receiver - owner of the shared memory */  
+	if( (error = mos_to_net(owner, (void *)&ra1)) < 0 ) 
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("Error %d in mos_to_net\n", error);
+		sock_release(sock);
+		return error;
+#endif /* CONFIG_SHM_DEBUG */
+	}
+	else
+	{
+		ra1.sin_family = AF_INET;
+		ra1.sin_port = MIG_SHM_DAEMON_PORT;
+
+		msg.msg_control = NULL;
+		msg.msg_controllen = 0;
+		msg.msg_iovlen = 2;
+		msg.msg_iov = iov;
+
+		hlen = sizeof(mig_shm_head);
+		size = sizeof(bshm);
+		mig_shm_head.type = SHM_PAGE;
+		mig_shm_head.dlen = size;
+
+		iov[0].iov_base = &mig_shm_head;  /* header */
+		iov[0].iov_len = hlen; 
+		iov[1].iov_base = &bshm;          /* data */
+		iov[1].iov_len = size; 
+	
+		msg_size = hlen + size;
+
+		msg.msg_name = &ra1;
+		msg.msg_flags = 0;
+		msg.msg_namelen = sizeof(struct sockaddr_in);
+		
+		if( !PageLocked(page))
+			PAGE_BUG(page);
+		
+		oldfs = get_fs();
+
+		set_fs(KERNEL_DS);
+
+		error = sock_sendmsg( sock, &msg, msg_size);
+		set_fs(oldfs);
+		
+		msg.msg_control = NULL;
+		msg.msg_controllen = 0;
+		msg.msg_iovlen = 1;
+		msg.msg_iov = &iov;
+		
+		iov[0].iov_len = PAGE_SIZE;
+		buffer = (char*)kmalloc(PAGE_SIZE,GFP_KERNEL);
+		iov[0].iov_base = ( void *)buffer;
+      
+		msg.msg_name = &ra2;
+		msg.msg_flags = 0;
+		msg.msg_namelen = sizeof(struct sockaddr_in);
+
+		size = 0;
+
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+
+		size = sock_recvmsg(sock, &msg, PAGE_SIZE ,0);
+		set_fs(oldfs);
+
+		if( size == PAGE_SIZE )
+		{
+			memcpy(kmap(page),(void*)buffer,PAGE_SIZE);
+			kunmap(page);
+			kfree((const void*)buffer);
+			SetPageUptodate(page);
+			UnlockPage(page);
+		}
+	}
+	sock_release( sock );
+	return(0);  
+}
+
+/* 
+ * get_shm_page - The owner of the shared memory returns the requested page 
+ * from its page cache to the mig_shm_daemon.
+ */
+void  get_shm_page(struct bring_shm_page_h* bshm, char *data, int from_node)
+{
+	struct vm_area_struct *vma = NULL;
+	struct address_space *mapping = NULL;
+	struct file *file;
+	struct shmeminfo *travshm = head_info;
+	struct processinfo *travproc = NULL; 
+	struct task_struct *p;
+	struct page *page, **hash;
+	struct shmid_kernel *shp;
+
+	while(travshm)
+	{
+		if((travshm->shmid == bshm->shmid) && (travshm->shm_home == bshm->home_node))
+		{
+			travproc = travshm->process_link;
+			break;
+		}
+		travshm = travshm->next_shmid;
+	}
+		
+	if(!travproc)
+	{
+		/* Addition to Known-Bug-list */
+		/* ------------------------- */
+		/* There is no process attached to shared memory in this
+		 * remote owner node. We want to send the shared memory
+		 * to the node from where the last writeback came. But
+		 * we dont know who this node is? Also we cant send the
+		 * ownership of the sharde memory to `from_node`... since
+		 * a reader/writer from that node page_faulted here for the
+		 * memory page. So, that node definitely has no pages */
+
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d- get_shm_page: Cannot find process_link\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		if(PE == bshm->home_node)
+		{
+			shp = shm_lock(bshm->shmid);
+			if(shp)
+			{
+				file = shp->shm_file;
+				mapping = file->f_dentry->d_inode->i_mapping;
+				goto page_alloc;
+			}
+#ifdef CONFIG_SHM_DEBUG
+			else
+	        		printk("%d-get_shm_page: shp not found", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		}
+	}
+	else
+	{  
+		p = find_any_task_by_pid(travproc->pid);
+		if(p)
+		{
+			vma = find_vma(p->mm, travproc->vmstart);
+			if(vma)
+				mapping = vma->vm_file->f_dentry->d_inode->i_mapping;
+			hash = page_hash(mapping, bshm->pageoff);
+			page = __find_get_page(mapping, bshm->pageoff, hash);
+			if(page)
+			{
+				memcpy((void*)data,kmap(page),PAGE_SIZE);
+				kunmap(page);
+			}
+			else
+			{
+#ifdef CONFIG_SHM_DEBUG
+				printk("%d-get_shm_page: Page not found\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+			page_alloc:
+				page = page_cache_alloc(mapping);
+				if(page)
+				{
+					hash = page_hash(mapping,bshm->pageoff);
+					add_to_page_cache(page, mapping, bshm->pageoff);
+					if( (PE != bshm->home_node) && (from_node != bshm->home_node))  
+						send_page_request( bshm->home_node, *bshm, page);
+					else
+					{
+						memset(kmap(page),0,PAGE_SIZE);
+						SetPageUptodate(page);
+						if(PageLocked(page))
+						{
+							UnlockPage(page);
+						}
+						kunmap(page);
+					}
+					memcpy((void*)data,kmap(page),PAGE_SIZE);
+					kunmap(page);
+				}
+#ifdef CONFIG_SHM_DEBUG
+				else
+					printk("%d-get_shm_page: Page not allocated.\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+			}    
+		}
+	}
+}
+/*
+ * mig_shm_daemon- This daemon is listening for any shared memory process 
+ * messages for its peers on remote nodes. 
+ */
+int mig_shm_daemon(void *nothing) 
+{
+	int error, hlen = sizeof(struct mig_shm_msg_h), size;
+	/* The biggest structure around is the shm_sync_h. */
+	int maxdlen = sizeof(struct shm_sync_h);
+	int msg_size = 0, from_node, sock_fd = 0;
+	struct mig_shm_msg_h mig_shm_head;
+	struct socket *sock_listen;
+	struct sockaddr_in sa, ra;
+	struct iovec iov[2], iov1;
+	struct msghdr msg;
+	mm_segment_t oldfs;
+	void* data, *page;
+	struct thread_sync_h* shmhdr;
+	void* buffer;
+
+	printk("\nStarting MigSharedMemD:\n");
+	strcpy(current->comm, "MigSharedMemD");
+	daemonize();
+
+restart:
+	wait_for_mosix_configuration(&mig_shm_daemon_active);
+	
+	sa.sin_family = PF_INET;
+	sa.sin_port = MIG_SHM_DAEMON_PORT;
+	sa.sin_addr.s_addr = INADDR_ANY;
+
+	if((error = sock_create(AF_INET, SOCK_DGRAM, IPPROTO_UDP, &sock_listen)) < 0 )
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("Error %d in sock_create()\n", sock_fd);
+		return error;
+#endif /* CONFIG_SHM_DEBUG */
+	}
+	if((error = sock_listen->ops->bind(sock_listen, (struct sockaddr *)&sa, sizeof(struct sockaddr_in))) < 0 )
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("Error %d in sock_bind()\n", error);
+		sock_release(sock_listen);
+		return error;
+#endif /* CONFIG_SHM_DEBUG */
+	}
+
+	data = kmalloc(maxdlen, GFP_KERNEL);
+	while(1)
+	{
+		msg.msg_control = NULL;
+		msg.msg_controllen = 0;
+		msg.msg_iov = iov;
+		msg.msg_iovlen = 2;
+		
+		iov[0].iov_len = hlen;
+		iov[0].iov_base = (void*)&mig_shm_head;
+
+		iov[1].iov_len = maxdlen;
+		iov[1].iov_base = (void*)data;
+		
+		msg.msg_name = &ra;
+		msg.msg_namelen = sizeof(struct sockaddr_in);
+		msg_size = hlen + maxdlen;
+		
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		size = sock_recvmsg(sock_listen, &msg, msg_size , 0);
+		set_fs(oldfs);
+	
+		if(size > 0)
+		{ 
+			from_node = net_to_mos((mosix_addr*)&ra);
+			if(from_node)
+			{
+			switch(mig_shm_head.type)
+			{
+			case WRITEBACK:
+				/* A remote writer(w.r.t. PE) released lock */
+				if((size-8) == sizeof(struct shm_sync_h))
+				{
+#ifdef CONFIG_SHM_DEBUG
+					printk("---WRITEBACK-from %d\n", from_node);
+#endif /* CONFIG_SHM_DEBUG */
+					recv_and_sync_page((struct shm_sync_h*)data, from_node);
+					send_invalidate_msg((struct shm_sync_h*)data, from_node);
+				}
+				break;
+			case INVALIDATE:
+				/* This shared page has been modified by 
+				 * someone else. Invalidate my pte so that the
+				 * next access will generate a page fault and
+				 * fetching of the latest page from shm_owner
+				 */
+				if((size-8) == sizeof(struct invalidate_h))
+				{
+					if( (from_node != PE) && ( ((struct invalidate_h*)data)->writer_node != PE))
+					{
+#ifdef CONFIG_SHM_DEBUG
+						printk("---INVALIDATE-from %d\n", from_node);
+#endif /* CONFIG_SHM_DEBUG */						
+						invalidate_pte((struct invalidate_h*)data);
+					}
+				}
+				break;
+			case SHM_OWNER_BROADCAST:
+				/* The shared memory has migrated to a new 
+				 * node. Change the owner node entry in my
+				 * structure on this node if I am remotely
+				 * executing.
+				 */
+				if((size-8) == sizeof(struct shm_mig_info_h))
+				{
+#ifdef CONFIG_SHM_DEBUG
+					printk("---SHM_OWNER_BROADCAST-from %d(for shmid %d)\n", from_node, ((struct shm_mig_info_h*)data)->shmid);
+#endif /* CONFIG_SHM_DEBUG */						
+					update_shm_mig((struct shm_mig_info_h*)data);
+				}
+				break;
+			case SHM_PAGE:
+				/* I am the owner node of the shared memory
+				 * region. A page fault invoked this message
+				 * to fetch the latest copy of the page from
+				 * here.
+				 */
+				if((size-8) == sizeof(struct bring_shm_page_h))
+				{
+					printk("---SHM_PAGE request-from %d\n", from_node);
+					page = (char*)kmalloc(PAGE_SIZE,GFP_KERNEL);
+					get_shm_page((struct bring_shm_page_h*)data, page, from_node);
+					msg.msg_control = NULL;
+					msg.msg_controllen = 0;
+					msg.msg_iovlen = 1;
+					msg.msg_iov = &iov1;
+				
+					iov1.iov_len = PAGE_SIZE;
+					iov1.iov_base = (void*)page;
+					msg.msg_name = &ra;
+					msg.msg_namelen = sizeof(struct sockaddr_in);
+
+					oldfs = get_fs();
+					
+					set_fs(KERNEL_DS);
+					
+					error = sock_sendmsg(sock_listen, &msg, PAGE_SIZE);
+					set_fs(oldfs);
+
+					kfree((const void*)page);
+				}
+				break;
+			case SYNC_DATA:
+				/* A thread released lock...sending modified 
+				 * data section to its remote siblings
+				 */
+				if((size-8) == sizeof(struct thread_sync_h))
+				{
+					shmhdr = (struct thread_sync_h *)data;
+					buffer = (char *)(shmhdr->data);
+					if( from_node != PE )
+					{
+#ifdef CONFIG_SHM_DEBUG
+						//	printk("---SYNC_DATA-from %d\n", from_node);
+#endif /* CONFIG_SHM_DEBUG */
+						sync_thread_section((struct thread_sync_h **)&data);
+					}
+				}
+				break;
+			default: 
+#ifdef CONFIG_SHM_DEBUG
+				printk("\n%d-MigSharedMemD: Received bad message type: %d!!\n", current->pid, mig_shm_head.type);
+#endif /* CONFIG_SHM_DEBUG */
+				break;  
+			}
+			}
+		}
+		else
+		{      
+			/* Received ( -ve # of bytes ) so exit */
+			kfree((const void*)data);
+			break;
+		}
+	}
+	sock_release(sock_listen);
+	return(0);
+}
diff -urNa openMosix-2.4.21/mig_shm/sync.c Migshm-2.4.21/mig_shm/sync.c
--- openMosix-2.4.21/mig_shm/sync.c	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/mig_shm/sync.c	2003-07-12 12:06:00.000000000 +0530
@@ -0,0 +1,442 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+/* 
+ * linux/mig_shm/sync.c - This file has all the code related to handling the 
+ * consistency in case of remote accesses to the shared memory.
+ */
+
+#include <linux/rwsem.h>
+#include <linux/mm.h>
+#include <hpc/protocol.h>
+#include <hpc/routines.h>
+#include <hpc/comm.h>
+#include <linux/in.h>
+#include <linux/highmem.h>
+#include <linux/slab.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+#include <asm/tlb.h> 
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <mig_shm/log_info.h>
+#include <mig_shm/shm_comm.h>
+#include <mig_shm/sync.h>
+#include <linux/pagemap.h>
+#include <linux/vmalloc.h>
+#include <linux/smp_lock.h>
+#include <hpc/hpctask.h>
+
+#define for_each_remote_task(p) \
+        for (p = &init_task ; (p = p->next_task) != &init_task ; ) \
+                if(p->mosix.dflags & DREMOTE)
+
+int maask_flag_pgfault = 0;
+
+pte_t * get_pte(struct mm_struct *mm, unsigned long address ) 
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *ptep;
+	pgd = pgd_offset(mm, address);
+	if (pgd_none(*pgd) || pgd_bad(*pgd))
+		goto out;
+
+	pmd = pmd_offset(pgd, address);
+	if (pmd_none(*pmd) || pmd_bad(*pmd))
+		goto out;
+
+	ptep = pte_offset(pmd, address);
+	if (!ptep)
+		goto out;
+
+	return ( ptep );
+	
+   out:
+	return 0;
+}
+
+/* 
+ * recv_and_sync_page - The deputy syncs the page sent by a remote writer to 
+ * the right location on the home ndoe of tse sharde memory 
+ */
+
+int recv_and_sync_page( struct shm_sync_h *shmhdr, int from_node)
+{
+	struct task_struct* q;
+	struct vm_area_struct vma, *vm; 
+	struct page* page;
+	struct shmeminfo* travshm = head_info;
+	struct processinfo* travproc = NULL;
+	int found = 0;
+	void* tmp_addr;
+
+
+	while(travshm)
+	{
+		if((travshm->shmid == shmhdr->shmid) && 
+		   (travshm->shm_home == shmhdr->home) )
+		{
+			if(travshm->shm_owner != PE)
+				return 0;
+			if(travshm->process_link)
+			{
+				found = 1;
+				break;
+			}
+		}
+		travshm = travshm->next_shmid;
+	}
+
+	if(!found)
+	{
+		struct shm_mig_info_h b_cast;
+
+		b_cast.shmid = shmhdr->shmid;
+		b_cast.home_node = shmhdr->home;
+		b_cast.new_owner = from_node;
+		
+		if( mig_shm_sendmsg(SHM_OWNER_BROADCAST, (void*)&b_cast, sizeof(b_cast), -1, 1) < 0 )
+			return -1;
+		return 0;
+	}
+
+	for_each_remote_task(q)
+        {
+		for( vm = q->mm->mmap; vm; vm = vm->vm_next )
+		{
+			if( vm->vm_file )
+			{
+				if( (home_file(vm->vm_file) == shmhdr->fp) && (q->mosix.deppe == shmhdr->home) )
+				{
+					shmhdr->fp = vm->vm_file;
+					break;
+				}
+			}
+		}
+	}
+	vma.vm_start = shmhdr->start;
+	vma.vm_pgoff = shmhdr->pgoff;
+	vma.vm_end = shmhdr->end;
+	vma.vm_mm = NULL;
+	vma.vm_file = shmhdr->fp;
+	vma.vm_flags = 0;
+  
+	if(!(page = shmem_nopage(&vma, shmhdr->addr, 1)))
+	{
+#ifdef CONFIG_SHM_DEBUG
+		printk("%d-recv_and_sync_page: Page not found on owner while synching dirty page\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		return (-1);
+	}
+
+	tmp_addr = kmap(page);
+	memcpy( (void*)tmp_addr,(void*)shmhdr->data, PAGE_SIZE);
+	kunmap(page);
+  
+	return(0);
+}
+/* shm_writeback- This function sends dirty pages of the shared memory back 
+ * to the owner node.
+ */
+extern int shm_writeback(int shmid, void* shmaddr, int shm_owner)
+{
+	struct task_struct* p = current;
+	struct mm_struct *mm = p->mm;
+	struct vm_area_struct *shmd = NULL;
+	struct shm_sync_h *shmhdr = NULL;
+	pte_t *  pte;
+	unsigned long addr;
+	int retval = 0, size = 0;
+		
+	down_write(&mm->mmap_sem);
+	addr = (unsigned long)shmaddr;
+	shmd = find_vma(mm, addr);
+		
+	if(shmd)	 
+	{
+		shmhdr = (struct shm_sync_h *)kmalloc(sizeof(struct shm_sync_h), GFP_KERNEL);  
+		shmhdr->shmid = shmid;
+		if( current->mosix.dflags & DREMOTE )
+		{ 
+			shmhdr->fp = home_file(shmd->vm_file);
+			shmhdr->home = current->mosix.deppe;
+		}	
+		else 
+		{
+			shmhdr->fp = shmd->vm_file;
+			shmhdr->home = PE;		   
+		}
+		shmhdr->start = shmd->vm_start;
+		shmhdr->end = shmd->vm_end;
+		shmhdr->pgoff = shmd->vm_pgoff;
+		
+		for(addr = shmd->vm_start; addr < shmd->vm_end; addr += PAGE_SIZE)
+		{
+			pte = get_pte( p->mm , addr );
+			/* send only if the page is dirty */
+			if( pte && pte_dirty( *pte ) )
+			{
+				shmhdr->addr = addr;
+				memcpy( (void*)shmhdr->data, (void*)addr, PAGE_SIZE );
+				size = sizeof(struct shm_sync_h);
+				shmhdr->page_no = (addr - shmd->vm_start)/PAGE_SIZE;
+				if( mig_shm_sendmsg(WRITEBACK, shmhdr, size, shm_owner, 0) < 0 )
+				{
+#ifdef CONFIG_SHM_DEBUG
+					printk("%d-shm_writeback: Error in mig_shm_sendmsg\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+					return retval;
+				}
+				/* clean the pte after flushing it once */ 
+				*pte = pte_mkclean(*pte);
+			}
+		}
+		kfree((const void *)shmhdr); 
+	}
+#ifdef CONFIG_SHM_DEBUG
+	else
+		printk("%d-shm_writeback: vm_area_struct not found.\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+	up_write(&mm->mmap_sem);
+	return(0);
+}
+/* writeback_all- This function finds the shared memory information for this
+ * process and invokes either writebacks (if the process is not running on the
+ * owner node, or broadcasting of invcalidate messages to remote processes
+ */
+int writeback_all(void)
+{
+	struct shmeminfo* travshm;
+	struct processinfo* travproc;
+
+	lock_kernel();
+	travshm = head_info;
+
+	while(travshm)
+	{
+		travproc = travshm->process_link;
+		while(travproc)
+		{
+			if(travproc->pid == current->pid)
+			{
+				/* My shmid found */
+				if(travshm->shm_owner != PE)
+				{
+					shm_writeback(travshm->shmid, (void*)travproc->vmstart, travshm->shm_owner);
+				}
+				else
+					send_invalidate_all();
+			}
+			travproc = travproc->next_pid;
+		}
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+	return(0);
+}
+/* send_invalidate_msg- This function sends information of the shared memory
+ * pages for which the pte is to be invalidated on the remote. It gets 
+ * invoked on receipt of a writeback from a remote writer.
+ */
+int send_invalidate_msg(struct shm_sync_h *head, int from_node)
+{
+	int error = 0;
+	struct shmeminfo *travshm;
+	struct invalidate_h im;
+
+	lock_kernel();
+	travshm = head_info;
+	while(travshm != NULL)
+	{
+		if(travshm->shmid == head->shmid)
+		{
+#ifdef CONFIG_SHM_DEBUG
+//			printk("%d-send_invalidate_msg: Invalidate message broadcasted\n", current->pid);
+#endif/*CONFIG_SHM_DEBUG*/
+			im.home_node = travshm->shm_home;
+			im.page_no = head->page_no;
+			im.shmid = head->shmid;
+
+			if(from_node > 0)
+				im.writer_node = from_node;
+			else
+				im.writer_node = PE;
+			
+			error = mig_shm_sendmsg(INVALIDATE, (void*)&im, sizeof(struct invalidate_h), -1, 1);
+		}
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+
+	return(error);
+}
+/* send_invalidate_all- This function, invoked after a writer on the owner 
+ * node releases the semaphore. It doesn't have to do a writeback, and just
+ * send invalidate messages to all.
+ */
+int send_invalidate_all()
+{
+	struct task_struct* p = current;
+	struct shmeminfo* travshm;
+	struct processinfo* travproc;
+	struct shm_sync_h shmhdr;
+	struct mm_struct* mm;
+	struct vm_area_struct* shmd;
+	int shmid;
+	unsigned long addr;
+	pte_t* pte;
+	int size = 0;
+
+	lock_kernel();
+	travshm = head_info;
+	while(travshm)    {
+		travproc = travshm->process_link;
+		while(travproc)	{
+			if(travproc->pid == current->pid)    {
+				/* My shmid found */
+				mm = current->mm;	  	 
+				shmid = travshm->shmid;
+				addr = travproc->vmstart;
+				shmd = find_vma(mm, addr);
+				if(shmd) 	{
+					shmhdr.shmid = shmid;
+					shmhdr.start = shmd->vm_start;
+					shmhdr.end = shmd->vm_end;
+					shmhdr.pgoff = shmd->vm_pgoff;
+					for(addr = shmd->vm_start; addr < shmd->vm_end; addr += PAGE_SIZE)		    {
+						pte = get_pte(p->mm , addr );
+						if( pte && pte_dirty( *pte ) )	    {
+							shmhdr.addr = addr;
+							size = sizeof(shmhdr);
+							shmhdr.page_no = (addr - shmd->vm_start)/4096;
+							send_invalidate_msg(&shmhdr, -1);
+							*pte = pte_mkclean(*pte);
+						}
+					} 
+				}
+#ifdef CONFIG_SHM_DEBUG
+				else
+					printk("%d-send_invalidate_all: Vma not found.\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+			}
+			travproc = travproc->next_pid;
+		}
+		travshm = travshm->next_shmid;
+	}
+	unlock_kernel();
+
+	return(0);
+}
+/* invalidate_pte- This function invalidates the page table entry and also
+ * removes the page physically from the memory frame.
+ */
+int invalidate_pte(struct invalidate_h* im)
+{
+	struct shmeminfo *travshm = head_info;
+	struct processinfo *travproc = NULL;
+	struct task_struct *p = NULL;
+	struct file* file;
+	struct vm_area_struct* vm;
+	struct address_space* mapping;
+	struct page** hash;
+	struct page *page;
+	unsigned long addr, pgoff, endoff;
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+	while(travshm)
+	{
+		if((travshm->shmid == im->shmid) && (travshm->shm_home == im->home_node))
+		{
+			travproc = travshm->process_link;
+			while(travproc)
+			{
+				p = find_any_task_by_pid(travproc->pid);
+				if ( !p )
+					goto bad;
+				addr = (unsigned long)(travproc->vmstart + (im->page_no * 4096));
+				pgd = pgd_offset(p->mm, addr);
+				if(pgd_none(*pgd) || pgd_bad(*pgd))
+					goto bad;
+				pmd = pmd_offset(pgd, addr);
+				if(pmd_none(*pmd) || pmd_bad(*pmd))
+					goto bad;
+				ptep = pte_offset(pmd, addr);
+				if(!ptep)
+					goto bad;
+				pte = *ptep;
+				
+				if (pte_present(pte))
+				{
+					vm = find_vma(p->mm, addr);
+					file = vm->vm_file;
+					mapping = file->f_dentry->d_inode->i_mapping;
+					pgoff = ((addr - vm->vm_start) >> PAGE_CACHE_SHIFT) + vm->vm_pgoff;
+					endoff = ((vm->vm_end - vm->vm_start) >> PAGE_CACHE_SHIFT) + vm->vm_pgoff;
+					hash = page_hash(mapping, pgoff);
+					page = __find_get_page(mapping, pgoff, hash);
+					if(page)	
+					{	     
+						LockPage(page);		      
+						if(PageDirty(page))
+							ClearPageDirty(page);
+						remove_inode_page(page);
+					}
+					pte_clear(ptep);
+				}
+				else
+				{
+					vm = find_vma(p->mm, addr);
+					file = vm->vm_file;
+					mapping = file->f_dentry->d_inode->i_mapping;
+					pgoff = ((addr - vm->vm_start) >> PAGE_CACHE_SHIFT) + vm->vm_pgoff;
+					endoff = ((vm->vm_end - vm->vm_start) >> PAGE_CACHE_SHIFT) + vm->vm_pgoff;
+					hash = page_hash(mapping, pgoff);
+					page = __find_get_page(mapping, pgoff, hash);
+					if(page)
+					{
+						LockPage(page);
+						if(PageDirty(page))
+							ClearPageDirty(page);
+						remove_inode_page(page);
+					}
+				}
+				travproc = travproc->next_pid;
+			}
+		}
+		travshm = travshm->next_shmid;
+	}
+ bad:
+	return -1;
+}
+
+#ifdef CONFIG_SHM_FLUSH
+asmlinkage long sys_flush(void)
+{
+
+	if((current->mosix.mig_flags & IF_SHMAT) && (current->mosix.mig_flags & WRITER))
+	{
+		if(writeback_all() < 0)
+			return -1;
+	}
+	if((current->mosix.mig_flags & MIG_CLONE) && (current->mosix.dflags & DREMOTE))
+	{
+		if(send_thread_section(current, DATA_SECTION, -1) < 0)
+			return -1;
+	}
+	return 0;
+}
+#endif /* CONFIG_SHM_FLUSH */
+
diff -urNa openMosix-2.4.21/mig_shm/thread.c Migshm-2.4.21/mig_shm/thread.c
--- openMosix-2.4.21/mig_shm/thread.c	1970-01-01 05:30:00.000000000 +0530
+++ Migshm-2.4.21/mig_shm/thread.c	2003-07-12 12:06:00.000000000 +0530
@@ -0,0 +1,258 @@
+/*
+ * Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Permission to use this software is hereby granted under the terms of the
+ * GNU General Public License, as published by the Free Software Foundation.
+ *
+ */
+/*
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
+
+/*
+ * thread.c - This file has all code related to thread migration. It basically
+ * deals with sending and syncing the data and the stack sections of the
+ * threads.   
+ */
+
+#include <linux/mm.h>
+#include <linux/highmem.h>
+#include <linux/sched.h>
+#include <asm/mman.h>
+#include <mig_shm/shm_comm.h>
+#include <mig_shm/thread.h>
+
+/*
+ * sync_thread_section - This function syncs the sections of the threads. A new
+ * page may have to be allocated for the thread here, before syncing it. 
+ */
+void sync_thread_section( struct thread_sync_h** data)
+{
+	struct task_struct* q, *p; 
+	struct thread_sync_h* shmhdr;
+	struct mm_struct* mm;
+	struct vm_area_struct *vma; 
+	struct page* page;
+  
+	shmhdr = *data;
+	mm = NULL;
+
+	for_each_task(q)
+	{
+		/* The parent always stays at the deputy. */
+		if( (q->pid == shmhdr->ppid) && (shmhdr->node == PE) )
+		{ 
+			mm = q->mm;
+			break;
+		}
+		else if( (q->mosix.ppid == shmhdr->ppid) && (q->mosix.deppe == shmhdr->node))
+		{
+			mm = q->mm;
+			break;
+		}
+	}
+	
+	if(mm)
+	{
+		page = follow_page(mm, shmhdr->addr, 0);
+		if(page)
+		{
+			memcpy((void *)(kmap(page)+shmhdr->offset),(void*)shmhdr->data,shmhdr->size);
+			kunmap(page);
+#ifdef CONFIG_SHM_DEBUG
+//			printk("%d-sync_thread_section: Data section synched.\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		}
+		else
+		{
+			vma = find_vma(q->mm,(q->mm->brk-1));
+			down_write(&mm->mmap_sem);
+			
+			vma->vm_end = PAGE_ALIGN(shmhdr->addr-PAGE_SIZE) + 2*PAGE_SIZE;
+			mm->brk = vma->vm_end;
+			handle_mm_fault(mm, vma, PAGE_ALIGN(shmhdr->addr-PAGE_SIZE), 1);
+			up_write(&mm->mmap_sem);
+	  
+			page = follow_page(mm, (shmhdr->addr), 0);
+			if(page)
+			{
+				memcpy((void *)(kmap(page)+shmhdr->offset),(void*)shmhdr->data,shmhdr->size);
+				kunmap(page);
+				printk("Data section overwritten\n");
+			}
+#ifdef CONFIG_SHM_DEBUG
+			else
+				printk("%d-sync_thread_section: Page not found\n", current->pid);
+#endif /* CONFIG_SHM_DEBUG */
+		}
+	}
+}
+
+/*
+ * send_thread_section - Depending upon the type parameter passed to it, this 
+ * function sends the part of the thread's address space between   
+ */
+int send_thread_section(struct task_struct *p, int type, int peer)
+{
+	struct vm_area_struct *vma;
+	struct page *page;
+	struct pt_regs *regs;
+	struct thread_sync_h *shmhdr;
+	struct mm_struct* mm = p->mm;	
+	unsigned long addr, limit, start_stack, start_data;  
+	int stack_size, data_size;  
+	int broadcast = 0, retval = 0;
+	unsigned long *start;
+
+	regs=((struct pt_regs*)(THREAD_SIZE+(unsigned long)p))-1;
+	
+	/* send the thread's data section */
+	if( !mm )
+	{
+		printk("No mm only!!\n");
+		return -1;
+	}
+	down_write(&mm->mmap_sem);
+
+	if(type == DATA_SECTION)
+		vma = find_vma(p->mm, p->mm->start_data);
+	/*
+	 * send the thread's user mode stack: i.e the portion between 
+	 * start_stack and the current value of the stack pointer 
+	 */
+	else if(type == THREAD_STACK_SECTION)
+	{
+		vma = find_vma(p->mm, p->mosix.start_stack);
+		limit = vma->vm_end;
+	}
+	/*
+	 * Send the stack section of the parent. This is typically required 
+	 * when the thread  migrates and needs to access the arguments passed 
+	 * to clone() when it was  created.       
+	 */
+	else if(type == PARENT_STACK_SECTION)
+	{
+		vma = find_vma(p->mm, p->mm->start_stack);
+		limit = vma->vm_end;
+	}
+	if(vma && (type == DATA_SECTION))
+	{
+		data_size = p->mm->start_brk - p->mm->start_data;
+		start_data = p->mm->start_data;
+      
+		while(data_size > 0)
+		{
+			shmhdr = (struct thread_sync_h *)kmalloc(sizeof(struct thread_sync_h), GFP_KERNEL);
+			shmhdr->addr = start_data;
+			if(p->mm->start_brk  > PAGE_ALIGN(start_data+1))
+			{
+				/* data crossing the page boundary */
+				shmhdr->size = PAGE_ALIGN(start_data+1) - start_data;
+				shmhdr->offset = shmhdr->addr - PAGE_ALIGN(shmhdr->addr-PAGE_SIZE);
+			}
+			else
+			{
+				shmhdr->size = p->mm->start_brk - start_data;
+				shmhdr->offset = shmhdr->addr - PAGE_ALIGN(shmhdr->addr-PAGE_SIZE+1);
+			}
+			if( shmhdr->size == 0 )
+				break;
+			data_size -= shmhdr->size;
+
+			start = &start_data;
+			memcpy((void*)shmhdr->data,(void*)(*start), shmhdr->size);
+			if( p->mosix.dflags & DREMOTE )
+				shmhdr->node = p->mosix.deppe;
+			else 
+				shmhdr->node = PE;
+			
+			if(p->mosix.ppid == 0) /* parent on deputy */
+				shmhdr->ppid = p->pid;
+			else
+				shmhdr->ppid = p->mosix.ppid;
+
+			if( peer == -1 )
+				broadcast = 1;
+	  
+			mig_shm_sendmsg(SYNC_DATA, (void *)shmhdr, sizeof(struct thread_sync_h), peer, broadcast);
+			start_data += shmhdr->size;
+			kfree((const void *)shmhdr);
+		}
+	}
+	else if(vma && (type == PARENT_STACK_SECTION))
+	{
+		for(addr = vma->vm_start; addr != limit; addr += PAGE_SIZE)
+		{
+			page = follow_page(p->mm, addr, 0);
+			if(page)
+			{
+				shmhdr = (struct thread_sync_h *)kmalloc(sizeof(struct thread_sync_h), GFP_KERNEL);
+				shmhdr->addr = addr;
+				memcpy((void*)shmhdr->data,kmap(page),PAGE_SIZE);
+				kunmap(page);
+
+				if( p->mosix.dflags & DREMOTE)
+					shmhdr->node = p->mosix.deppe;
+				else
+					shmhdr->node = PE;
+
+				if(p->mosix.ppid == 0) /* parent on deputy */
+					shmhdr->ppid = p->pid;
+				else
+					shmhdr->ppid = p->mosix.ppid;
+
+				shmhdr->size = PAGE_SIZE;
+				shmhdr->offset = 0;
+
+				if( peer == -1 )
+					broadcast = 1;	   
+				mig_shm_sendmsg(SYNC_DATA, (void *)shmhdr, sizeof(struct thread_sync_h), peer,broadcast);
+				kfree((const void *)shmhdr);
+			}
+		}
+	}
+	else if(vma && type == THREAD_STACK_SECTION)
+	{
+		stack_size = p->mosix.start_stack - regs->esp + 10;
+		start_stack = regs->esp;
+		
+		while( stack_size > 0)
+		{
+			shmhdr = (struct thread_sync_h *)kmalloc(sizeof(struct thread_sync_h), GFP_KERNEL);
+			shmhdr->addr = start_stack;
+			if(p->mosix.start_stack+10  > PAGE_ALIGN(start_stack+1))
+			{
+				/* data crossing the page boundary */
+				shmhdr->size = PAGE_ALIGN(start_stack) - start_stack;
+				shmhdr->offset = shmhdr->addr - PAGE_ALIGN(shmhdr->addr-PAGE_SIZE);
+			}
+			else
+			{
+				shmhdr->size = p->mosix.start_stack+10 - start_stack;
+				shmhdr->offset = shmhdr->addr - PAGE_ALIGN(shmhdr->addr-PAGE_SIZE+1);
+			}
+			stack_size -= shmhdr->size;
+
+			start = &start_stack;
+			memcpy((void*)shmhdr->data,(void*)(*start),shmhdr->size);
+
+			if( p->mosix.dflags & DREMOTE )
+				shmhdr->node = p->mosix.deppe;
+			else
+				shmhdr->node = PE;
+			if(p->mosix.ppid == 0) /* parent on deputy */
+				shmhdr->ppid = p->pid;
+			else
+				shmhdr->ppid = p->mosix.ppid;
+			if( peer == -1 )
+				broadcast = 1;
+     
+			mig_shm_sendmsg(SYNC_DATA, (void *)shmhdr, sizeof(struct thread_sync_h), peer, broadcast); 
+			start_stack += shmhdr->size;     
+			kfree((const void *)shmhdr);
+		}
+	}
+	up_write(&mm->mmap_sem);
+	return retval;
+}
diff -urNa openMosix-2.4.21/mm/filemap.c Migshm-2.4.21/mm/filemap.c
--- openMosix-2.4.21/mm/filemap.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/mm/filemap.c	2003-07-12 12:06:00.000000000 +0530
@@ -3,6 +3,12 @@
  *
  * Copyright (C) 1994-1999  Linus Torvalds
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 /*
  * This file handles the generic file mmap semantics used by
@@ -36,6 +42,11 @@
 #ifdef CONFIG_MOSIX_DFSA
 #include <linux/dfsa_interface.h>
 #endif /* CONFIG_MOSIX_DFSA */
+#ifdef CONFIG_SHM
+#include <mig_shm/log_info.h>
+#include <mig_shm/sync.h>
+#include <mig_shm/shm_comm.h>
+#endif /* CONFIG_SHM */
 
 /*
  * Shared mappings implemented 30.11.1994. It's not fully working yet,
@@ -88,8 +99,11 @@
 		PAGE_BUG(page);
 	atomic_inc(&page_cache_size);
 }
-
+#ifdef CONFIG_SHM
+void add_page_to_inode_queue(struct address_space *mapping, struct page * page)
+#else
 static inline void add_page_to_inode_queue(struct address_space *mapping, struct page * page)
+#endif
 {
 	struct list_head *head = &mapping->clean_pages;
 
@@ -716,6 +730,10 @@
 	struct address_space *mapping = file->f_dentry->d_inode->i_mapping;
 	struct page **hash = page_hash(mapping, offset);
 	struct page *page;
+#ifdef CONFIG_SHM
+        struct bring_shm_page_h bshm;
+        struct shmeminfo* travshm;
+#endif /* CONFIG_SHM */
 
 	spin_lock(&pagecache_lock);
 	page = __find_page_nolock(mapping, offset, *hash);
@@ -727,6 +745,35 @@
 	if (!page)
 		return -ENOMEM;
 
+#ifdef CONFIG_SHM
+        /*
+         * If the shared memory has migrated to a node, then that node becomes
+         * the owner of the shared memory. Thus any remote page fault for this
+         * migrated shared memory should go to the owner of the shared memory
+         * and not the home node of the process.
+         */
+
+        if( file->f_dentry->d_inode->u.remote_i.nopage == (nopage_t)shmem_nopage)
+	{
+		travshm = get_shmeminfo(current->pid);
+		if ( !travshm )
+			return -EINVAL;
+		if((travshm->shm_owner != travshm->shm_home) && (travshm->shm_owner != PE))
+		{
+
+			bshm.shmid = travshm->shmid;
+			bshm.pageoff = offset;
+			bshm.home_node = travshm->shm_home;
+			bshm.page_no = 0;
+			if (!add_to_page_cache_unique(page, mapping, offset, hash)) {
+				send_page_request(travshm->shm_owner, bshm, page);
+				return 0;
+			}
+		}
+	}
+
+#endif /* CONFIG_SHM */
+   
 	if (!add_to_page_cache_unique(page, mapping, offset, hash)) {
 		int error = mapping->a_ops->readpage(file, page);
 		page_cache_release(page);
diff -urNa openMosix-2.4.21/mm/memory.c Migshm-2.4.21/mm/memory.c
--- openMosix-2.4.21/mm/memory.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/mm/memory.c	2003-07-12 12:06:00.000000000 +0530
@@ -406,7 +406,10 @@
 /*
  * Do a quick page-table lookup for a single page.
  */
-static struct page * follow_page(struct mm_struct *mm, unsigned long address, int write)
+#ifndef CONFIG_SHM
+static 
+#endif /* CONFIG_SHM */
+struct page * follow_page(struct mm_struct *mm, unsigned long address, int write)
 {
 	pgd_t *pgd;
 	pmd_t *pmd;
@@ -1049,7 +1052,6 @@
 
 bad_wp_page:
 	spin_unlock(&mm->page_table_lock);
-	printk("do_wp_page: bogus page at address %08lx (page 0x%lx)\n",address,(unsigned long)old_page);
 	return -1;
 no_mem:
 	page_cache_release(old_page);
diff -urNa openMosix-2.4.21/mm/mmap.c Migshm-2.4.21/mm/mmap.c
--- openMosix-2.4.21/mm/mmap.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/mm/mmap.c	2003-07-12 12:06:00.000000000 +0530
@@ -5,6 +5,12 @@
  *
  * Address space accounting code	<alan@redhat.com>
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 #include <linux/slab.h>
 #include <linux/shm.h>
@@ -622,14 +628,19 @@
 	if (file) {
 		switch (flags & MAP_TYPE) {
 		case MAP_SHARED:
+#ifndef CONFIG_SHM
 			if ((prot & PROT_WRITE) && !(file->f_mode & FMODE_WRITE))
 				return -EACCES;
-
+#endif /* CONFIG_SHM */
 			/* Make sure we don't allow writing to an append-only file.. */
+#ifndef CONFIG_SHM
 			if (IS_APPEND(file->f_dentry->d_inode) && (file->f_mode & FMODE_WRITE))
 				return -EACCES;
+#endif /* CONFIG_SHM */
 
-			/* make sure there are no mandatory locks on the file. */
+#ifdef CONFIG_SHM
+			if( !(current->mosix.dflags & DREMOTE) )
+#endif /*CONFIG_SHM*/
 			if (locks_verify_locked(file->f_dentry->d_inode))
 				return -EAGAIN;
 
@@ -637,6 +648,9 @@
 			if (!(file->f_mode & FMODE_WRITE))
 				vm_flags &= ~(VM_MAYWRITE | VM_SHARED);
 #ifdef CONFIG_MOSIX
+#ifdef CONFIG_SHM
+				if( !(current->mosix.mig_flags & IF_SHMAT ) && !(current->mosix.mig_flags & MIG_CLONE) )
+#endif/*CONFIG_SHM*/
 			if(file->f_mode & FMODE_WRITE)
 				reason_to_come_back |= DSTAY_FOR_MONKEY;
 #endif /* CONFIG_MOSIX */
@@ -644,14 +658,21 @@
 			/* fall through */
 		case MAP_PRIVATE:
 #ifdef CONFIG_MOSIX
+
+#ifndef CONFIG_SHM	
 			if(file->f_dentry->d_inode->i_mapping->i_mmap_shared)
 				reason_to_come_back |= DSTAY_FOR_MONKEY;
+#endif/*CONFIG_SHM*/	
 			if(S_ISCHR(file->f_dentry->d_inode->i_mode))
 				reason_to_come_back |= DSTAY_FOR_DEV;
 			if (!(current->mosix.dflags & DINCOMING))
 #endif /* CONFIG_MOSIX */
+			{
+#ifndef CONFIG_SHM
 			if (!(file->f_mode & FMODE_READ))
 				return -EACCES;
+#endif /* CONFIG_SHM */
+			}
 			break;
 
 		default:
@@ -790,12 +811,14 @@
 		/* we did not really want that vma... only to check */
 		kmem_cache_free(vm_area_cachep, vma);
 		/* meanwhile someone else could map the same file shared, so: */
+#ifndef CONFIG_SHM
 		if(file && file->f_dentry->d_inode->i_mapping->i_mmap_shared)
 		{
 			if(!mosix_go_home(0))
 				return(-EAGAIN);
 			stay_me_and_my_clones(DSTAY_FOR_MONKEY);
 		}
+#endif /* CONFIG_SHM */
 		return(addr);
 	}
 
@@ -815,7 +838,12 @@
 		error = file->f_op->mmap(file, vma);
 		if (error)
 			goto unmap_and_free_vma;
-	} else if (flags & MAP_SHARED) {
+	} else if ( (flags & MAP_SHARED) 
+#ifdef CONFIG_SHM
+		   && !(current->mosix.dflags & DREMOTE)
+#endif /* CONFIG_SHM */
+		) 
+	{
 		error = shmem_zero_setup(vma);
 		if (error)
 			goto free_vma;
@@ -864,8 +892,10 @@
 #ifdef CONFIG_MOSIX
 	if(reason_to_come_back)
 		stay_me_and_my_clones(reason_to_come_back);
+#ifndef CONFIG_SHM
 	if(file && (vm_flags & VM_SHARED))
 		mosix_bring_monkey_users_back(file->f_dentry->d_inode);
+#endif /* CONFIG_SHM */
 #endif /* CONFIG_MOSIX */
 	return addr;
 
diff -urNa openMosix-2.4.21/mm/shmem.c Migshm-2.4.21/mm/shmem.c
--- openMosix-2.4.21/mm/shmem.c	2003-07-12 11:14:04.000000000 +0530
+++ Migshm-2.4.21/mm/shmem.c	2003-07-12 12:06:00.000000000 +0530
@@ -9,6 +9,12 @@
  *
  * This file is released under the GPL.
  */
+/*
+ * Migshm code Copyright(C) 2002, 2003, MAASK group (maaskmaask@hotmail.com)
+ *
+ * Author(s): Maya Kagliwal, Anuradha Khandekar, Asmita Jagtap, Snehal Mundle 
+ *            Krushna Bagde
+ */
 
 /*
  * This virtual memory filesystem is heavily based on the ramfs. It
@@ -30,6 +36,12 @@
 #include <linux/locks.h>
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
+#ifdef CONFIG_SHM
+#include <mig_shm/log_info.h>
+#include <mig_shm/sync.h>
+#include <mig_shm/shm_comm.h>
+#include <hpc/routines.h>
+#endif /* CONFIG_SHM */
 
 /* This magic number is used in glibc for posix shared memory */
 #define TMPFS_MAGIC	0x01021994
@@ -664,22 +676,34 @@
 
 static int shmem_getpage(struct inode * inode, unsigned long idx, struct page **ptr)
 {
-	struct shmem_inode_info *info = SHMEM_I(inode);
 	int error;
+	struct shmem_inode_info *info = NULL;
 
+#ifdef CONFIG_SHM
+	if( strcmp(current->comm, "MigSharedMemD") != 0 )
+#endif /* CONFIG_SHM */
+		info = SHMEM_I(inode);
+	
+	if(info)
 	down (&info->sem);
+
 	*ptr = ERR_PTR(-EFAULT);
+
 	if (inode->i_size <= (loff_t) idx * PAGE_CACHE_SIZE)
 		goto failed;
 
 	*ptr = shmem_getpage_locked(info, inode, idx);
+	
 	if (IS_ERR (*ptr))
 		goto failed;
 
 	UnlockPage(*ptr);
+	
+	if(info)
 	up (&info->sem);
 	return 0;
 failed:
+	if(info)
 	up (&info->sem);
 	error = PTR_ERR(*ptr);
 	*ptr = NOPAGE_SIGBUS;
@@ -693,14 +717,44 @@
 	struct page * page;
 	unsigned int idx;
 	struct inode * inode = vma->vm_file->f_dentry->d_inode;
+#ifdef CONFIG_SHM
+        int nrpages;
+        struct shmeminfo * travshm;
+        struct bring_shm_page_h bshm;
+#endif /*CONFIG_SHM*/
 
 	idx = (address - vma->vm_start) >> PAGE_CACHE_SHIFT;
 	idx += vma->vm_pgoff;
 
+#ifdef CONFIG_SHM
+	if(inode->i_mapping)
+		nrpages = inode->i_mapping->nrpages;
+#endif /* CONFIG_SHM */
+
 	if (shmem_getpage(inode, idx, &page))
 		return page;
 
 	flush_page_to_ram(page);
+#ifdef CONFIG_SHM
+        if( inode->i_mapping->nrpages > nrpages )
+	/* A new page has been allocated */
+	{
+		travshm = get_shmeminfo(current->pid);
+		if( (travshm && travshm->shm_owner != PE)  )
+		{
+			/* Owner found */
+			bshm.shmid = travshm->shmid;
+			bshm.pageoff = idx;
+			bshm.home_node = travshm->shm_home;
+			bshm.page_no = 0;           /* Maybe unused. */
+			if(!PageLocked(page))
+				LockPage(page);
+          /* Sync the newly allocated page to the owner of the shared memory */
+			send_page_request(travshm->shm_owner,bshm,page);
+		}
+	}
+#endif /*CONFIG_SHM*/
+
 	return(page);
 }
 
