diff -Nur bandwidthd-1.2.0b.orig/bandwidthd.c bandwidthd-1.2.0b/bandwidthd.c
--- bandwidthd-1.2.0b.orig/bandwidthd.c	2004-01-14 17:20:53.000000000 +0100
+++ bandwidthd-1.2.0b/bandwidthd.c	2004-01-25 22:26:31.000000000 +0100
@@ -1,3 +1,12 @@
+/*
+ * Modfied 2004-01-25 by Michel Blomgren <michel@sentinix.org>
+ * suggested by Chris Hammond <chris@bluecobras.com>:
+ *
+ * Added a cosmetic "title" variable to bandwidthd.conf to be able
+ * to specify a custom HTML <title></title> for all generated pages.
+ *
+ */
+
 #include <unistd.h>
 #include <errno.h>
 #include <sys/socket.h>
@@ -66,6 +75,8 @@
 		{
 		fprintf(index, "<HTML><HEAD>\n<META HTTP-EQUIV=\"REFRESH\" content=\"150\">\n<META HTTP-EQUIV=\"EXPIRES\" content=\"-1\">\n");
 		fprintf(index, "<META HTTP-EQUIV=\"PRAGMA\" content=\"no-cache\">\n");
+		if (config.title != NULL)
+		    fprintf(index, "<title>%s</title>\n", config.title);
 		fprintf(index, "</HEAD><BODY><center><img src=\"logo.gif\"><BR>\n");
 		fprintf(index, "<BR>\n - <a href=index.html>Daily</a> -- <a href=index2.html>Weekly</a> -- ");
 		fprintf(index, "<a href=index3.html>Monthly</a> -- <a href=index4.html>Yearly</a><BR>\n");
@@ -124,6 +135,7 @@
 	char Error[PCAP_ERRBUF_SIZE];
 	char CurrentDirWarning[] = "bandwidthd always works out of the current directory, cd to some place with a ./etc/bandwidthd.conf and a ./htdocs/ then run it";
 
+	config.title = NULL;
 	config.dev = NULL;
 	config.skip_intervals = CONFIG_GRAPHINTERVALS;
 	config.graph_cutoff = CONFIG_GRAPHCUTOFF;
diff -Nur bandwidthd-1.2.0b.orig/bandwidthd.h bandwidthd-1.2.0b/bandwidthd.h
--- bandwidthd-1.2.0b.orig/bandwidthd.h	2004-01-13 21:03:33.000000000 +0100
+++ bandwidthd-1.2.0b/bandwidthd.h	2004-01-25 21:44:55.000000000 +0100
@@ -57,6 +57,7 @@
 
 struct config
 	{
+	char *title;
 	char *dev;
 	unsigned int skip_intervals;
 	unsigned long long graph_cutoff;
diff -Nur bandwidthd-1.2.0b.orig/conf.l bandwidthd-1.2.0b/conf.l
--- bandwidthd-1.2.0b.orig/conf.l	2003-12-01 17:45:05.000000000 +0100
+++ bandwidthd-1.2.0b/conf.l	2004-01-25 21:53:42.000000000 +0100
@@ -22,5 +22,6 @@
 output_cdf				{ return TOKOUTPUTCDF; }		
 recover_cdf				{ return TOKRECOVERCDF; }		
 graph					{ return TOKGRAPH; }
+title					{ return TOKTITLE; }
 .						{ return TOKJUNK; }
 %%
diff -Nur bandwidthd-1.2.0b.orig/conf.l.c bandwidthd-1.2.0b/conf.l.c
--- bandwidthd-1.2.0b.orig/conf.l.c	2004-01-07 20:10:37.000000000 +0100
+++ bandwidthd-1.2.0b/conf.l.c	2004-01-25 22:16:03.000000000 +0100
@@ -293,32 +293,33 @@
 	yy_more_offset = 0; \
 	yy_c_buf_p = yy_cp;
 
-#define YY_NUM_RULES 17
-#define YY_END_OF_BUFFER 18
-static yyconst short int yy_acclist[56] =
+#define YY_NUM_RULES 18
+#define YY_END_OF_BUFFER 19
+static yyconst short int yy_acclist[57] =
     {   0,
-       18,   16,   17,    1,   16,   17,    1,   17,   16,   17,
-       16,   17,    4,   16,   17,    6,   16,   17,    4,   16,
-       17,   16,   17,   16,   17,   16,   17,   16,   17,   16,
-       17,   16,   17,   16,   17,   16,   17,    1,    5,    2,
-        4,    4,    4,    9,    7,   15,    8,    3,    3,    3,
-       13,   12,   14,   11,   10
+       19,   17,   18,    1,   17,   18,    1,   18,   17,   18,
+       17,   18,    4,   17,   18,    6,   17,   18,    4,   17,
+       18,   17,   18,   17,   18,   17,   18,   17,   18,   17,
+       18,   17,   18,   17,   18,   17,   18,    1,    5,    2,
+        4,    4,    4,    9,    7,   15,   16,    8,    3,    3,
+        3,   13,   12,   14,   11,   10
     } ;
 
-static yyconst short int yy_accept[108] =
+static yyconst short int yy_accept[112] =
     {   0,
         1,    1,    1,    2,    4,    7,    9,   11,   13,   16,
        19,   22,   24,   26,   28,   30,   32,   34,   36,   38,
        39,   39,   40,   40,   41,   42,   42,   43,   43,   43,
-       43,   43,   43,   43,   43,   43,   43,   43,   44,   45,
+       43,   43,   43,   43,   43,   43,   43,   43,   43,   44,
        45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
-       45,   45,   45,   45,   45,   45,   45,   46,   46,   46,
-       47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
-       47,   47,   47,   48,   49,   49,   49,   49,   49,   49,
-       49,   50,   50,   50,   50,   50,   50,   51,   51,   51,
-       51,   51,   51,   51,   52,   52,   52,   52,   52,   53,
+       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
+       46,   46,   46,   47,   47,   47,   47,   47,   47,   48,
+       48,   48,   48,   48,   48,   48,   48,   49,   50,   50,
+       50,   50,   50,   50,   50,   51,   51,   51,   51,   51,
+       51,   52,   52,   52,   52,   52,   52,   52,   53,   53,
 
-       54,   54,   55,   55,   55,   56,   56
+       53,   53,   53,   54,   55,   55,   56,   56,   56,   57,
+       57
     } ;
 
 static yyconst int yy_ec[256] =
@@ -360,82 +361,84 @@
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1
     } ;
 
-static yyconst short int yy_base[109] =
+static yyconst short int yy_base[113] =
     {   0,
-        0,    0,  140,  141,   29,   31,  135,  135,   29,  141,
-       30,  122,  125,  109,  105,  107,  117,   20,  105,   39,
-      126,  125,  125,  141,   37,  118,   38,   96,  104,  113,
-       95,   98,  108,  101,  107,   89,   41,   45,  141,   90,
-       91,   90,   92,   89,   87,   88,   95,  100,   46,   93,
-       89,   77,   86,   74,   93,   87,  141,   49,   94,   90,
-       71,   71,   82,   77,   67,   85,   50,   80,   82,   78,
-       64,   66,  141,   79,   80,   57,   72,   55,   73,   54,
-       72,   52,   65,   54,   64,   61,  141,   51,   58,   44,
-       58,   45,   54,  141,   42,   52,   37,   50,  141,  141,
+        0,    0,  144,  145,   29,   31,  139,  139,   29,  145,
+       30,  126,  129,  113,  109,  111,  121,   20,   22,   40,
+      131,  130,  130,  145,   38,  123,   44,  101,  109,  118,
+      100,  103,  113,  106,  112,   95,   93,   45,   49,  145,
+       94,   95,   94,   96,   93,   91,   92,   93,   98,  103,
+       50,   96,   92,   80,   89,   77,   96,   90,   89,  145,
+       53,   96,   92,   73,   73,   84,   79,   69,  145,   87,
+       54,   82,   84,   80,   66,   68,  145,   81,   82,   59,
+       74,   57,   75,   56,   74,   54,   67,   56,   66,   63,
+      145,   53,   60,   46,   60,   47,   56,  145,   44,   54,
 
-       54,  141,   43,   36,  141,  141,   61,   59
+       39,   52,  145,  145,   56,  145,   45,   19,  145,  145,
+       44,   63
     } ;
 
-static yyconst short int yy_def[109] =
+static yyconst short int yy_def[113] =
     {   0,
-      106,    1,  106,  106,  106,  106,  107,  108,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      107,  107,  108,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
+      110,    1,  110,  110,  110,  110,  111,  112,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      111,  111,  112,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
 
-      106,  106,  106,  106,  106,    0,  106,  106
+      110,  110,  110,  110,  110,  110,  110,  110,  110,    0,
+      110,  110
     } ;
 
-static yyconst short int yy_nxt[172] =
+static yyconst short int yy_nxt[176] =
     {   0,
         4,    5,    6,    7,    8,    9,    4,   10,   11,    4,
         4,    4,    4,   12,    4,   13,   14,    4,    4,    4,
         4,    4,    4,   15,   16,   17,   18,   19,    4,    4,
        20,   20,   20,   20,   25,   25,   26,   25,   27,   34,
-       20,   20,   25,   25,   26,   25,   38,   48,   35,   49,
-       25,   26,   48,   25,   59,   66,   66,   67,   75,   23,
-       23,   21,  105,  104,  103,  102,  101,  100,   99,   98,
-       97,   96,   95,   94,   93,   92,   91,   90,   89,   88,
-       87,   86,   85,   84,   83,   82,   66,   81,   80,   79,
-       78,   77,   76,   74,   73,   72,   71,   70,   69,   68,
-
-       48,   65,   64,   63,   62,   61,   60,   57,   58,   57,
-       56,   55,   54,   53,   52,   51,   50,   47,   46,   45,
-       44,   43,   42,   41,   40,   39,   37,   24,   22,   22,
-       36,   33,   32,   31,   30,   29,   28,   24,   22,  106,
-        3,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106
+       36,   20,   20,   25,   21,  109,   25,   37,   35,   25,
+       26,   50,   39,   51,   25,   26,   50,   25,   62,   70,
+       70,   71,   79,   23,   23,  108,  107,  106,  105,  104,
+      103,  102,  101,  100,   99,   98,   97,   96,   95,   94,
+       93,   92,   91,   90,   89,   88,   87,   86,   70,   85,
+       84,   83,   82,   81,   80,   78,   77,   76,   75,   74,
+
+       73,   72,   50,   69,   68,   67,   66,   65,   64,   63,
+       60,   61,   60,   59,   58,   57,   56,   55,   54,   53,
+       52,   49,   48,   47,   46,   45,   44,   43,   42,   41,
+       40,   38,   24,   22,   22,   33,   32,   31,   30,   29,
+       28,   24,   22,  110,    3,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110
     } ;
 
-static yyconst short int yy_chk[172] =
+static yyconst short int yy_chk[176] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         5,    5,    6,    6,    9,   11,   11,    9,   11,   18,
-       20,   20,   25,   27,   27,   25,   27,   37,   18,   37,
-       38,   38,   49,   38,   49,   58,   67,   58,   67,  108,
-      108,  107,  104,  103,  101,   98,   97,   96,   95,   93,
-       92,   91,   90,   89,   88,   86,   85,   84,   83,   82,
-       81,   80,   79,   78,   77,   76,   75,   74,   72,   71,
-       70,   69,   68,   66,   65,   64,   63,   62,   61,   60,
-
-       59,   56,   55,   54,   53,   52,   51,   50,   48,   47,
-       46,   45,   44,   43,   42,   41,   40,   36,   35,   34,
-       33,   32,   31,   30,   29,   28,   26,   23,   22,   21,
-       19,   17,   16,   15,   14,   13,   12,    8,    7,    3,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106,  106,  106,  106,  106,  106,  106,  106,  106,  106,
-      106
+       19,   20,   20,   25,  111,  108,   25,   19,   18,   27,
+       27,   38,   27,   38,   39,   39,   51,   39,   51,   61,
+       71,   61,   71,  112,  112,  107,  105,  102,  101,  100,
+       99,   97,   96,   95,   94,   93,   92,   90,   89,   88,
+       87,   86,   85,   84,   83,   82,   81,   80,   79,   78,
+       76,   75,   74,   73,   72,   70,   68,   67,   66,   65,
+
+       64,   63,   62,   59,   58,   57,   56,   55,   54,   53,
+       52,   50,   49,   48,   47,   46,   45,   44,   43,   42,
+       41,   37,   36,   35,   34,   33,   32,   31,   30,   29,
+       28,   26,   23,   22,   21,   17,   16,   15,   14,   13,
+       12,    8,    7,    3,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110
     } ;
 
 static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
@@ -671,14 +674,14 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 107 )
+				if ( yy_current_state >= 111 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			*yy_state_ptr++ = yy_current_state;
 			++yy_cp;
 			}
-		while ( yy_base[yy_current_state] != 141 );
+		while ( yy_base[yy_current_state] != 145 );
 
 yy_find_action:
 		yy_current_state = *--yy_state_ptr;
@@ -792,11 +795,16 @@
 case 16:
 YY_RULE_SETUP
 #line 25 "conf.l"
-{ return TOKJUNK; }
+{ return TOKTITLE; }
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
 #line 26 "conf.l"
+{ return TOKJUNK; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 27 "conf.l"
 YY_FATAL_ERROR( "flex scanner jammed" );
 	YY_BREAK
 			case YY_STATE_EOF(INITIAL):
@@ -1087,7 +1095,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 107 )
+			if ( yy_current_state >= 111 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -1117,11 +1125,11 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 107 )
+		if ( yy_current_state >= 111 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 106);
+	yy_is_jam = (yy_current_state == 110);
 	if ( ! yy_is_jam )
 		*yy_state_ptr++ = yy_current_state;
 
@@ -1682,5 +1690,5 @@
 	return 0;
 	}
 #endif
-#line 26 "conf.l"
+#line 27 "conf.l"
 
diff -Nur bandwidthd-1.2.0b.orig/conf.tab.c bandwidthd-1.2.0b/conf.tab.c
--- bandwidthd-1.2.0b.orig/conf.tab.c	2004-01-07 20:10:36.000000000 +0100
+++ bandwidthd-1.2.0b/conf.tab.c	2004-01-25 22:16:03.000000000 +0100
@@ -1,23 +1,23 @@
-
-/*  A Bison parser, made from conf.y
-    by GNU Bison version 1.28  */
+/* A Bison parser, made from conf.y
+   by GNU bison 1.35.  */
 
 #define YYBISON 1  /* Identify Bison output.  */
 
-#define	TOKJUNK	257
-#define	TOKSUBNET	258
-#define	TOKDEV	259
-#define	TOKSLASH	260
-#define	TOKSKIPINTERVALS	261
-#define	TOKGRAPHCUTOFF	262
-#define	TOKPROMISC	263
-#define	TOKOUTPUTCDF	264
-#define	TOKRECOVERCDF	265
-#define	TOKGRAPH	266
-#define	IPADDR	267
-#define	NUMBER	268
-#define	STRING	269
-#define	STATE	270
+# define	TOKJUNK	257
+# define	TOKSUBNET	258
+# define	TOKDEV	259
+# define	TOKSLASH	260
+# define	TOKSKIPINTERVALS	261
+# define	TOKGRAPHCUTOFF	262
+# define	TOKPROMISC	263
+# define	TOKOUTPUTCDF	264
+# define	TOKRECOVERCDF	265
+# define	TOKGRAPH	266
+# define	TOKTITLE	267
+# define	IPADDR	268
+# define	NUMBER	269
+# define	STRING	270
+# define	STATE	271
 
 #line 1 "conf.y"
 
@@ -56,149 +56,177 @@
 	}
 
 #line 39 "conf.y"
+#ifndef YYSTYPE
 typedef union
 {
     int number;
     char *string;
-} YYSTYPE;
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
+} yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
 #endif
+#ifndef YYDEBUG
+# define YYDEBUG 0
 #endif
 
 
 
-#define	YYFINAL		34
+#define	YYFINAL		37
 #define	YYFLAG		-32768
-#define	YYNTBASE	17
+#define	YYNTBASE	18
 
-#define YYTRANSLATE(x) ((unsigned)(x) <= 270 ? yytranslate[x] : 30)
+/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
+#define YYTRANSLATE(x) ((unsigned)(x) <= 271 ? yytranslate[x] : 32)
 
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16
+/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
+static const char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17
 };
 
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     1,     4,     6,     8,    10,    12,    14,    16,    18,
-    20,    22,    24,    28,    33,    35,    38,    41,    44,    47,
-    50,    53
+#if YYDEBUG
+static const short yyprhs[] =
+{
+       0,     0,     1,     4,     6,     8,    10,    12,    14,    16,
+      18,    20,    22,    24,    26,    30,    35,    37,    40,    43,
+      46,    49,    52,    55,    58
 };
-
-static const short yyrhs[] = {    -1,
-    17,    18,     0,    19,     0,    23,     0,    24,     0,    25,
-     0,    26,     0,    27,     0,    28,     0,    29,     0,    20,
-     0,    21,     0,     4,    13,    13,     0,     4,    13,     6,
-    14,     0,    15,     0,     5,    22,     0,     7,    14,     0,
-     8,    14,     0,     9,    16,     0,    10,    16,     0,    11,
-    16,     0,    12,    16,     0
+static const short yyrhs[] =
+{
+      -1,    18,    19,     0,    20,     0,    24,     0,    25,     0,
+      26,     0,    27,     0,    28,     0,    29,     0,    30,     0,
+      31,     0,    21,     0,    22,     0,     4,    14,    14,     0,
+       4,    14,     6,    15,     0,    16,     0,     5,    23,     0,
+       7,    15,     0,     8,    15,     0,     9,    17,     0,    10,
+      17,     0,    11,    17,     0,    12,    17,     0,    13,    23,
+       0
 };
 
 #endif
 
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    52,    53,    56,    58,    60,    62,    64,    66,    68,    70,
-    74,    76,    80,    94,   114,   122,   129,   136,   143,   153,
-   163,   173
+#if YYDEBUG
+/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
+static const short yyrline[] =
+{
+       0,    52,    53,    56,    58,    60,    62,    64,    66,    68,
+      70,    72,    76,    78,    82,    96,   116,   124,   131,   138,
+     145,   155,   165,   175,   185
 };
 #endif
 
 
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+#if (YYDEBUG) || defined YYERROR_VERBOSE
 
-static const char * const yytname[] = {   "$","error","$undefined.","TOKJUNK",
-"TOKSUBNET","TOKDEV","TOKSLASH","TOKSKIPINTERVALS","TOKGRAPHCUTOFF","TOKPROMISC",
-"TOKOUTPUTCDF","TOKRECOVERCDF","TOKGRAPH","IPADDR","NUMBER","STRING","STATE",
-"commands","command","subnet","subneta","subnetb","string","device","skip_intervals",
-"graph_cutoff","promisc","output_cdf","recover_cdf","graph", NULL
+/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
+static const char *const yytname[] =
+{
+  "$", "error", "$undefined.", "TOKJUNK", "TOKSUBNET", "TOKDEV", "TOKSLASH", 
+  "TOKSKIPINTERVALS", "TOKGRAPHCUTOFF", "TOKPROMISC", "TOKOUTPUTCDF", 
+  "TOKRECOVERCDF", "TOKGRAPH", "TOKTITLE", "IPADDR", "NUMBER", "STRING", 
+  "STATE", "commands", "command", "subnet", "subneta", "subnetb", 
+  "string", "device", "skip_intervals", "graph_cutoff", "promisc", 
+  "output_cdf", "recover_cdf", "graph", "title", 0
 };
 #endif
 
-static const short yyr1[] = {     0,
-    17,    17,    18,    18,    18,    18,    18,    18,    18,    18,
-    19,    19,    20,    21,    22,    23,    24,    25,    26,    27,
-    28,    29
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
+static const short yyr1[] =
+{
+       0,    18,    18,    19,    19,    19,    19,    19,    19,    19,
+      19,    19,    20,    20,    21,    22,    23,    24,    25,    26,
+      27,    28,    29,    30,    31
 };
 
-static const short yyr2[] = {     0,
-     0,     2,     1,     1,     1,     1,     1,     1,     1,     1,
-     1,     1,     3,     4,     1,     2,     2,     2,     2,     2,
-     2,     2
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
+static const short yyr2[] =
+{
+       0,     0,     2,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     3,     4,     1,     2,     2,     2,
+       2,     2,     2,     2,     2
 };
 
-static const short yydefact[] = {     1,
-     0,     0,     0,     0,     0,     0,     0,     0,     0,     2,
-     3,    11,    12,     4,     5,     6,     7,     8,     9,    10,
-     0,    15,    16,    17,    18,    19,    20,    21,    22,     0,
-    13,    14,     0,     0
+/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+   doesn't specify something else to do.  Zero means the default is an
+   error. */
+static const short yydefact[] =
+{
+       1,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     2,     3,    12,    13,     4,     5,     6,     7,     8,
+       9,    10,    11,     0,    16,    17,    18,    19,    20,    21,
+      22,    23,    24,     0,    14,    15,     0,     0
 };
 
-static const short yydefgoto[] = {     1,
-    10,    11,    12,    13,    23,    14,    15,    16,    17,    18,
-    19,    20
+static const short yydefgoto[] =
+{
+       1,    11,    12,    13,    14,    25,    15,    16,    17,    18,
+      19,    20,    21,    22
 };
 
-static const short yypact[] = {-32768,
-     0,   -12,   -13,   -11,    -8,    -2,    -1,     1,     2,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-     7,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,     5,
--32768,-32768,    16,-32768
+static const short yypact[] =
+{
+  -32768,     0,   -13,   -14,   -12,    -9,    -2,    -1,     1,     2,
+     -14,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+  -32768,-32768,-32768,     8,-32768,-32768,-32768,-32768,-32768,-32768,
+  -32768,-32768,-32768,     5,-32768,-32768,    17,-32768
 };
 
-static const short yypgoto[] = {-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768
+static const short yypgoto[] =
+{
+  -32768,-32768,-32768,-32768,-32768,    11,-32768,-32768,-32768,-32768,
+  -32768,-32768,-32768,-32768
 };
 
 
-#define	YYLAST		20
+#define	YYLAST		22
 
 
-static const short yytable[] = {    33,
-    21,    22,    24,     2,     3,    25,     4,     5,     6,     7,
-     8,     9,    30,    26,    27,    34,    28,    29,    32,    31
+static const short yytable[] =
+{
+      36,    23,    24,    26,     2,     3,    27,     4,     5,     6,
+       7,     8,     9,    10,    33,    28,    29,    37,    30,    31,
+      35,    32,    34
 };
 
-static const short yycheck[] = {     0,
-    13,    15,    14,     4,     5,    14,     7,     8,     9,    10,
-    11,    12,     6,    16,    16,     0,    16,    16,    14,    13
+static const short yycheck[] =
+{
+       0,    14,    16,    15,     4,     5,    15,     7,     8,     9,
+      10,    11,    12,    13,     6,    17,    17,     0,    17,    17,
+      15,    10,    14
 };
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/share/bison.simple"
-/* This file comes from bison-1.28.  */
+#line 3 "/usr/share/bison/bison.simple"
 
 /* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
+   Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -220,62 +248,131 @@
    This special exception was added by the Free Software Foundation
    in version 1.24 of Bison.  */
 
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
+/* This is the parser code that is written into each bison parser when
+   the %semantic_parser declaration is not specified in the grammar.
+   It was written by Richard Stallman by simplifying the hairy parser
+   used when %semantic_parser is specified.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+# if YYLSP_NEEDED
+  YYLTYPE yyls;
+# endif
+};
 
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# if YYLSP_NEEDED
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+      + 2 * YYSTACK_GAP_MAX)
+# else
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAX)
+# endif
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
@@ -284,131 +381,161 @@
 #define YYACCEPT	goto yyacceptlab
 #define YYABORT 	goto yyabortlab
 #define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
 #define YYFAIL		goto yyerrlab
 #define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
+#define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
       yychar1 = YYTRANSLATE (yychar);				\
       YYPOPSTACK;						\
       goto yybackup;						\
     }								\
   else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+    { 								\
+      yyerror ("syntax error: cannot back up");			\
+      YYERROR;							\
+    }								\
 while (0)
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
 
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).
 
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
+   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
+   first token.  By default, to implement support for ranges, extend
+   its range to the last symbol.  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
+   Current.last_line   = Rhs[N].last_line;	\
+   Current.last_column = Rhs[N].last_column;
 #endif
 
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
 
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#if YYPURE
+# if YYLSP_NEEDED
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval, &yylloc)
+#  endif
+# else /* !YYLSP_NEEDED */
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval)
+#  endif
+# endif /* !YYLSP_NEEDED */
+#else /* !YYPURE */
+# define YYLEX			yylex ()
+#endif /* !YYPURE */
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+#endif /* !YYDEBUG */
 
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
+# define YYINITDEPTH 200
 #endif
 
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
 
 #if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
+# undef YYMAXDEPTH
 #endif
 
 #ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
+# define YYMAXDEPTH 10000
 #endif
 
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+#ifdef YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
 
-  while (i-- > 0)
-    *t++ = *f++;
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
 }
+#  endif
+# endif
 
-#else /* __cplusplus */
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
 
-  while (i-- > 0)
-    *t++ = *f++;
+  return yyd - 1;
 }
-
-#endif
+#  endif
+# endif
 #endif
 
-#line 217 "/usr/share/bison.simple"
+#line 315 "/usr/share/bison/bison.simple"
+
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -417,76 +544,121 @@
    to the proper pointer type.  */
 
 #ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
+# if defined (__STDC__) || defined (__cplusplus)
+#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL
+# else
+#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+# endif
+#else /* !YYPARSE_PARAM */
+# define YYPARSE_PARAM_ARG
+# define YYPARSE_PARAM_DECL
+#endif /* !YYPARSE_PARAM */
 
 /* Prevent warning if -Wstrict-prototypes.  */
 #ifdef __GNUC__
-#ifdef YYPARSE_PARAM
+# ifdef YYPARSE_PARAM
 int yyparse (void *);
-#else
+# else
 int yyparse (void);
+# endif
 #endif
+
+/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
+   variables are global, or local to YYPARSE.  */
+
+#define YY_DECL_NON_LSP_VARIABLES			\
+/* The lookahead symbol.  */				\
+int yychar;						\
+							\
+/* The semantic value of the lookahead symbol. */	\
+YYSTYPE yylval;						\
+							\
+/* Number of parse errors so far.  */			\
+int yynerrs;
+
+#if YYLSP_NEEDED
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES			\
+						\
+/* Location data for the lookahead symbol.  */	\
+YYLTYPE yylloc;
+#else
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES
 #endif
 
+
+/* If nonreentrant, generate the variables here. */
+
+#if !YYPURE
+YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
 int
-yyparse(YYPARSE_PARAM_ARG)
+yyparse (YYPARSE_PARAM_ARG)
      YYPARSE_PARAM_DECL
 {
+  /* If reentrant, generate the variables here. */
+#if YYPURE
+  YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
   register int yystate;
   register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yychar1 = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack. */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
   register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
 
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
 
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+#if YYLSP_NEEDED
+  /* The location stack.  */
+  YYLTYPE yylsa[YYINITDEPTH];
   YYLTYPE *yyls = yylsa;
   YYLTYPE *yylsp;
+#endif
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#if YYLSP_NEEDED
+# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
 #else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+# define YYPOPSTACK   (yyvsp--, yyssp--)
 #endif
 
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
+  YYSIZE_T yystacksize = YYINITDEPTH;
 
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
 
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+#if YYLSP_NEEDED
+  YYLTYPE yyloc;
+#endif
 
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule. */
   int yylen;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
@@ -498,110 +670,110 @@
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
 
-  yyssp = yyss - 1;
+  yyssp = yyss;
   yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp = yyls;
 #endif
+  goto yysetstate;
 
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
 
-  *++yyssp = yystate;
+ yysetstate:
+  *yyssp = yystate;
 
   if (yyssp >= yyss + yystacksize - 1)
     {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
       /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
+      YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  */
+# if YYLSP_NEEDED
+	YYLTYPE *yyls1 = yyls;
+	/* This used to be a conditional around just the two extra args,
+	   but that might be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yyls1, yysize * sizeof (*yylsp),
+		    &yystacksize);
+	yyls = yyls1;
+# else
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+# endif
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
 #else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
       /* Extend the stack our own way.  */
       if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
+	goto yyoverflowlab;
       yystacksize *= 2;
       if (yystacksize > YYMAXDEPTH)
 	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+# if YYLSP_NEEDED
+	YYSTACK_RELOCATE (yyls);
+# endif
+# undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
 #endif /* no yyoverflow */
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+#if YYLSP_NEEDED
+      yylsp = yyls + yysize - 1;
 #endif
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
 
       if (yyssp >= yyss + yystacksize - 1)
 	YYABORT;
     }
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   goto yybackup;
- yybackup:
+
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
 
 /* Do appropriate processing given the current state.  */
 /* Read a lookahead token if we need one and don't already have one.  */
@@ -620,10 +792,7 @@
 
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
@@ -634,25 +803,25 @@
       yychar1 = 0;
       yychar = YYEOF;		/* Don't call YYLEX any more */
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
+      yychar1 = YYTRANSLATE (yychar);
 
-#if YYDEBUG != 0
+#if YYDEBUG
+     /* We have to keep this `#if YYDEBUG', since we use variables
+	which are defined only if `YYDEBUG' is set.  */
       if (yydebug)
 	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
+	  YYFPRINTF (stderr, "Next token is %d (%s",
+		     yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise
+	     meaning of a token, for further debugging info.  */
+# ifdef YYPRINT
 	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
+# endif
+	  YYFPRINTF (stderr, ")\n");
 	}
 #endif
     }
@@ -684,60 +853,82 @@
     YYACCEPT;
 
   /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
+  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
+	      yychar, yytname[yychar1]));
 
   /* Discard the token being shifted unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   *++yylsp = yylloc;
 #endif
 
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
   yystate = yyn;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
-yydefault:
 
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
+  goto yyreduce;
 
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
 
-#if YYDEBUG != 0
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to the semantic value of
+     the lookahead token.  This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+#if YYLSP_NEEDED
+  /* Similarly for the default location.  Let the user run additional
+     commands if for instance locations are ranges.  */
+  yyloc = yylsp[1-yylen];
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+#endif
+
+#if YYDEBUG
+  /* We have to keep this `#if YYDEBUG', since we use variables which
+     are defined only if `YYDEBUG' is set.  */
   if (yydebug)
     {
-      int i;
+      int yyi;
 
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
+      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
+		 yyn, yyrline[yyn]);
 
       /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
+	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
     }
 #endif
 
-
   switch (yyn) {
 
-case 13:
-#line 82 "conf.y"
+case 14:
+#line 84 "conf.y"
 {
 	struct in_addr addr;
 
@@ -750,8 +941,8 @@
 	printf("with netmask %s\n", inet_ntoa(addr));
 	;
     break;}
-case 14:
-#line 96 "conf.y"
+case 15:
+#line 98 "conf.y"
 {
 	unsigned int Subnet, Counter, Mask;
 	struct in_addr addr;
@@ -770,36 +961,36 @@
 	printf("with netmask %s\n", inet_ntoa(addr));
 	;
     break;}
-case 15:
-#line 116 "conf.y"
+case 16:
+#line 118 "conf.y"
 {
     yyvsp[0].string[strlen(yyvsp[0].string)-1] = '\0';
     yyval.string = yyvsp[0].string+1;
     ;
     break;}
-case 16:
-#line 124 "conf.y"
+case 17:
+#line 126 "conf.y"
 {
 	config.dev = yyvsp[0].string;
 	//printf("Using device: %s\n", config.dev);
 	;
     break;}
-case 17:
-#line 131 "conf.y"
+case 18:
+#line 133 "conf.y"
 {
 	config.skip_intervals = yyvsp[0].number+1;
 	printf("Graphing every %d intervals.\n", config.skip_intervals);
 	;
     break;}
-case 18:
-#line 138 "conf.y"
+case 19:
+#line 140 "conf.y"
 {
 	config.graph_cutoff = yyvsp[0].number*1024;
 	printf("Not graphing IP's with less than %llu bytes of traffic.\n", config.graph_cutoff);
 	;
     break;}
-case 19:
-#line 145 "conf.y"
+case 20:
+#line 147 "conf.y"
 {
 	config.promisc = yyvsp[0].number;
 	if (config.promisc)
@@ -808,8 +999,8 @@
 		printf("Promiscuous mode off\n");
 	;
     break;}
-case 20:
-#line 155 "conf.y"
+case 21:
+#line 157 "conf.y"
 {
 	config.output_cdf = yyvsp[0].number;
 	if (config.output_cdf)
@@ -818,8 +1009,8 @@
 		printf("Logging to cdf disabled.\n");
 	;
     break;}
-case 21:
-#line 165 "conf.y"
+case 22:
+#line 167 "conf.y"
 {
 	config.recover_cdf = yyvsp[0].number;
 	if (config.recover_cdf)
@@ -828,8 +1019,8 @@
 		printf("cdf loading disabled.\n");
 	;
     break;}
-case 22:
-#line 175 "conf.y"
+case 23:
+#line 177 "conf.y"
 {
 	config.graph = yyvsp[0].number;
 	if (config.graph)
@@ -838,50 +1029,43 @@
 		printf("Graphing disabled.\n");
 	;
     break;}
+case 24:
+#line 187 "conf.y"
+{
+	config.title = yyvsp[0].string;
+	printf("HTML title: %s\n", config.title);
+	;
+    break;}
 }
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/share/bison.simple"
+
+#line 705 "/usr/share/bison/bison.simple"
+
 
   yyvsp -= yylen;
   yyssp -= yylen;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp -= yylen;
 #endif
 
-#if YYDEBUG != 0
+#if YYDEBUG
   if (yydebug)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
     }
 #endif
 
   *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
+#if YYLSP_NEEDED
+  *++yylsp = yyloc;
 #endif
 
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
 
   yyn = yyr1[yyn];
 
@@ -893,10 +1077,13 @@
 
   goto yynewstate;
 
-yyerrlab:   /* here on detecting error */
 
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
       ++yynerrs;
 
@@ -905,102 +1092,121 @@
 
       if (yyn > YYFLAG && yyn < YYLAST)
 	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
+	  YYSIZE_T yysize = 0;
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
 	    {
-	      strcpy(msg, "parse error");
+	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
 
-	      if (count < 5)
+	      if (yycount < 5)
 		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx)
 		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
 		      }
 		}
-	      yyerror(msg);
-	      free(msg);
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
 	    }
 	  else
-	    yyerror ("parse error; also virtual memory exceeded");
+	    yyerror ("parse error; also virtual memory exhausted");
 	}
       else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
+#endif /* defined (YYERROR_VERBOSE) */
+	yyerror ("parse error");
     }
-
   goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
 
+
+/*--------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action |
+`--------------------------------------------------*/
+yyerrlab1:
   if (yyerrstatus == 3)
     {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
 
       /* return failure if at end of input */
       if (yychar == YYEOF)
 	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
+      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
+		  yychar, yytname[yychar1]));
       yychar = YYEMPTY;
     }
 
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
 
   yyerrstatus = 3;		/* Each real token shifted decrements this */
 
   goto yyerrhandle;
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
 
+/*-------------------------------------------------------------------.
+| yyerrdefault -- current state does not do anything special for the |
+| error token.                                                       |
+`-------------------------------------------------------------------*/
+yyerrdefault:
 #if 0
   /* This is wrong; only states that explicitly want error tokens
      should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
+
+  /* If its default is to accept any token, ok.  Otherwise pop it.  */
+  yyn = yydefact[yystate];
+  if (yyn)
+    goto yydefault;
 #endif
 
-yyerrpop:   /* pop the current state because it cannot handle the error token */
 
-  if (yyssp == yyss) YYABORT;
+/*---------------------------------------------------------------.
+| yyerrpop -- pop the current state because it cannot handle the |
+| error token                                                    |
+`---------------------------------------------------------------*/
+yyerrpop:
+  if (yyssp == yyss)
+    YYABORT;
   yyvsp--;
   yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp--;
 #endif
 
-#if YYDEBUG != 0
+#if YYDEBUG
   if (yydebug)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "Error: state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
     }
 #endif
 
+/*--------------.
+| yyerrhandle.  |
+`--------------*/
 yyerrhandle:
-
   yyn = yypact[yystate];
   if (yyn == YYFLAG)
     goto yyerrdefault;
@@ -1023,41 +1229,44 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
+  YYDPRINTF ((stderr, "Shifting error token, "));
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   *++yylsp = yylloc;
 #endif
 
   yystate = yyn;
   goto yynewstate;
 
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
 
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+/*---------------------------------------------.
+| yyoverflowab -- parser overflow comes here.  |
+`---------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
 #endif
-    }
-  return 1;
+  return yyresult;
 }
-#line 182 "conf.y"
+#line 191 "conf.y"
diff -Nur bandwidthd-1.2.0b.orig/conf.tab.h bandwidthd-1.2.0b/conf.tab.h
--- bandwidthd-1.2.0b.orig/conf.tab.h	2004-01-07 20:10:36.000000000 +0100
+++ bandwidthd-1.2.0b/conf.tab.h	2004-01-25 22:16:03.000000000 +0100
@@ -1,22 +1,32 @@
+#ifndef BISON_CONF_TAB_H
+# define BISON_CONF_TAB_H
+
+#ifndef YYSTYPE
 typedef union
 {
     int number;
     char *string;
-} YYSTYPE;
-#define	TOKJUNK	257
-#define	TOKSUBNET	258
-#define	TOKDEV	259
-#define	TOKSLASH	260
-#define	TOKSKIPINTERVALS	261
-#define	TOKGRAPHCUTOFF	262
-#define	TOKPROMISC	263
-#define	TOKOUTPUTCDF	264
-#define	TOKRECOVERCDF	265
-#define	TOKGRAPH	266
-#define	IPADDR	267
-#define	NUMBER	268
-#define	STRING	269
-#define	STATE	270
+} yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+# define	TOKJUNK	257
+# define	TOKSUBNET	258
+# define	TOKDEV	259
+# define	TOKSLASH	260
+# define	TOKSKIPINTERVALS	261
+# define	TOKGRAPHCUTOFF	262
+# define	TOKPROMISC	263
+# define	TOKOUTPUTCDF	264
+# define	TOKRECOVERCDF	265
+# define	TOKGRAPH	266
+# define	TOKTITLE	267
+# define	IPADDR	268
+# define	NUMBER	269
+# define	STRING	270
+# define	STATE	271
 
 
 extern YYSTYPE yylval;
+
+#endif /* not BISON_CONF_TAB_H */
diff -Nur bandwidthd-1.2.0b.orig/conf.y bandwidthd-1.2.0b/conf.y
--- bandwidthd-1.2.0b.orig/conf.y	2003-12-02 17:54:35.000000000 +0100
+++ bandwidthd-1.2.0b/conf.y	2004-01-25 22:15:34.000000000 +0100
@@ -35,7 +35,7 @@
 %}
 
 %token TOKJUNK TOKSUBNET TOKDEV TOKSLASH TOKSKIPINTERVALS TOKGRAPHCUTOFF 
-%token TOKPROMISC TOKOUTPUTCDF TOKRECOVERCDF TOKGRAPH
+%token TOKPROMISC TOKOUTPUTCDF TOKRECOVERCDF TOKGRAPH TOKTITLE
 %union
 {
     int number;
@@ -69,6 +69,8 @@
 	recover_cdf
 	|
 	graph
+	|
+	title
 	;
 
 subnet:
@@ -179,3 +181,10 @@
 	else
 		printf("Graphing disabled.\n");
 	}
+
+title:
+	TOKTITLE string
+	{
+	config.title = $2;
+	printf("HTML title: %s\n", config.title);
+	}
diff -Nur bandwidthd-1.2.0b.orig/etc/bandwidthd.conf bandwidthd-1.2.0b/etc/bandwidthd.conf
--- bandwidthd-1.2.0b.orig/etc/bandwidthd.conf	2003-12-01 17:45:06.000000000 +0100
+++ bandwidthd-1.2.0b/etc/bandwidthd.conf	2004-01-25 22:28:44.000000000 +0100
@@ -4,6 +4,9 @@
 # Commented out options are here to provide
 # documentation and represent defaults
 
+# Title for all HTML pages
+title "bandwidthd"
+
 # Subnets to collect statistics on
 subnet 10.0.0.0 255.0.0.0
 subnet 208.16.191.0 255.255.255.0
diff -Nur bandwidthd-1.2.0b.orig/graph.c bandwidthd-1.2.0b/graph.c
--- bandwidthd-1.2.0b.orig/graph.c	2004-01-14 17:51:16.000000000 +0100
+++ bandwidthd-1.2.0b/graph.c	2004-01-25 22:14:53.000000000 +0100
@@ -247,6 +247,8 @@
 	
 	fprintf(file, "<HTML><HEAD>\n<META HTTP-EQUIV=\"REFRESH\" content=\"150\">\n<META HTTP-EQUIV=\"EXPIRES\" content=\"-1\">\n");
 	fprintf(file, "<META HTTP-EQUIV=\"PRAGMA\" content=\"no-cache\">\n");
+	if (config.title != NULL)
+	    fprintf(file, "<title>%s</title>\n", config.title);
 	fprintf(file, "</HEAD><BODY vlink=blue>\n%s<br>\n<center><img src=\"logo.gif\"><BR>\n", ctime(&WriteTime));
 	fprintf(file, "<BR>\n - <a href=index.html>Daily</a> -- <a href=index2.html>Weekly</a> -- ");
 	fprintf(file, "<a href=index3.html>Monthly</a> -- <a href=index4.html>Yearly</a> - <BR>\n");
@@ -305,6 +307,8 @@
 		sprintf(Buffer2, "./htdocs/Subnet-%c-%s.html", config.tag, Buffer1);
 		file = fopen(Buffer2, "w");
 		fprintf(file, "<HTML><HEAD>\n<META HTTP-EQUIV=\"REFRESH\" content=\"150\">\n<META HTTP-EQUIV=\"EXPIRES\" content=\"-1\">\n");
+		if (config.title != NULL)
+		    fprintf(file, "<title>%s</title>\n", config.title);
 		fprintf(file, "<META HTTP-EQUIV=\"PRAGMA\" content=\"no-cache\">\n</HEAD>\n<BODY vlink=blue>\n%s<br>\n<CENTER><a name=\"Top\">", ctime(&WriteTime));
 		fprintf(file, "<img src=\"logo.gif\"><BR>");
 
